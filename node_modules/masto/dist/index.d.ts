import { BodyInit, AbortSignal, RequestInit, HeadersInit, Headers } from '@mastojs/ponyfills';
import { SemVer } from 'semver';
import EventEmitter from 'eventemitter3';
import WebSocket from 'isomorphic-ws';

type LogType = 'debug' | 'info' | 'warn' | 'error';
declare class LogLevel {
    private readonly level;
    private constructor();
    satisfies(type: LogType): boolean;
    static from(type: LogType): LogLevel;
}

declare abstract class BaseLogger {
    private readonly logLevel;
    constructor(logLevel: LogLevel);
    abstract log(type: LogType, message: string, meta: unknown): void;
    debug(message: string, meta?: unknown): void;
    info(message: string, meta?: unknown): void;
    warn(message: string, meta?: unknown): void;
    error(message: string, meta?: unknown): void;
}

interface Logger {
    debug(message: string, meta?: unknown): void;
    info(message: string, meta?: unknown): void;
    warn(message: string, meta?: unknown): void;
    error(message: string, meta?: unknown): void;
}

declare class LoggerConsoleImpl extends BaseLogger implements Logger {
    constructor(logLevel: LogLevel);
    log(type: LogType, message: string, meta: unknown): void;
}

interface Serializer {
    serialize(type: string, data: unknown): BodyInit | undefined;
    serializeQueryString(data: unknown): string;
    deserialize<T = Record<string, unknown>>(type: string, data: unknown): T;
}

declare class SerializerNativeImpl implements Serializer {
    serialize(type: string, rawData: unknown): BodyInit | undefined;
    serializeQueryString(rawData: unknown): string;
    deserialize<T = Record<string, unknown>>(type: string, data: string): T;
}

declare class Timeout {
    private readonly abortController;
    private readonly timeout;
    constructor(millisecond: number);
    get signal(): AbortSignal;
    clear(): void;
}

type VersionCompat = 'unimplemented' | 'removed' | 'compatible';
type SatisfiesVersionRangeResult = {
    compat: VersionCompat;
    version?: string;
};
type MastoConfigProps = {
    readonly url: string;
    readonly streamingApiUrl?: string;
    readonly logLevel?: LogType;
    readonly version?: SemVer;
    readonly accessToken?: string;
    readonly timeout?: number;
    readonly defaultRequestInit?: Omit<RequestInit, 'body' | 'method'>;
    readonly disableVersionCheck?: boolean;
    readonly disableDeprecatedWarning?: boolean;
};
declare class MastoConfig {
    private readonly props;
    private readonly serializer;
    constructor(props: MastoConfigProps, serializer: Serializer);
    createHeader(override?: HeadersInit): Headers;
    createWebsocketProtocols(protocols?: never[]): string[];
    resolveHttpPath(path: string, params?: Record<string, unknown>): URL;
    resolveWebsocketPath(path: string, params?: Record<string, unknown>): string;
    createTimeout(): Timeout;
    createAbortSignal(signal?: AbortSignal | null): [AbortSignal, Timeout];
    getLogLevel(): LogLevel;
    shouldWarnDeprecated(): boolean;
    satisfiesVersion(since?: SemVer, until?: SemVer): SatisfiesVersionRangeResult;
    private supportsSecureToken;
}

type HttpMethod = <T>(path: string, data?: unknown, request?: RequestInit) => Promise<T>;
type HttpRequestParams = {
    readonly path: string;
    readonly searchParams?: Record<string, unknown>;
    readonly body?: Record<string, unknown>;
    readonly requestInit?: Omit<RequestInit, 'body'>;
};
type HttpRequestResult = {
    headers: Headers;
    data: unknown;
};
interface Http {
    readonly request: (params: HttpRequestParams) => Promise<HttpRequestResult>;
    readonly get: HttpMethod;
    readonly post: HttpMethod;
    readonly patch: HttpMethod;
    readonly put: HttpMethod;
    readonly delete: HttpMethod;
}

declare abstract class BaseHttp implements Http {
    abstract request(params: HttpRequestParams): Promise<HttpRequestResult>;
    get<T>(path: string, data?: unknown, init?: RequestInit): Promise<T>;
    post<T>(path: string, data?: unknown, init?: RequestInit): Promise<T>;
    delete<T>(path: string, data?: unknown, init?: RequestInit): Promise<T>;
    put<T>(path: string, data?: unknown, init?: RequestInit): Promise<T>;
    patch<T>(path: string, data?: unknown, init?: RequestInit): Promise<T>;
}

declare class HttpNativeImpl extends BaseHttp implements Http {
    private readonly serializer;
    private readonly config;
    private readonly logger?;
    constructor(serializer: Serializer, config: MastoConfig, logger?: Logger | undefined);
    request(params: HttpRequestParams): Promise<HttpRequestResult>;
    private createRequest;
    private createError;
}

/**
 * Represents display or publishing preferences of user's own account.
 * Returned as an additional entity when verifying and updated credentials, as an attribute of Account.
 * @see https://docs.joinmastodon.org/entities/source/
 */
interface AccountSource {
    /** Profile bio. */
    note: string;
    /** Metadata about the account. */
    fields: AccountField;
    /** The default post privacy to be used for new statuses. */
    privacy?: StatusVisibility | null;
    /** Whether new statuses should be marked sensitive by default. */
    sensitive?: boolean | null;
    /** The default posting language for new statuses. */
    language: string | null;
    /** The number of pending follow requests. */
    followRequestsCount?: number | null;
}
/**
 * Represents a profile field as a name-value pair with optional verification.
 */
interface AccountField {
    /** The key of a given field's key-value pair. */
    name: string;
    /** The value associated with the `name` key. */
    value: string;
    /** Timestamp of when the server verified a URL value for a rel="me” link. */
    verifiedAt?: string | null;
}
/**
 * Represents a user of Mastodon and their associated profile.
 * @see https://docs.joinmastodon.org/entities/account/
 */
interface Account$1 {
    /** The account id */
    id: string;
    /** The username of the account, not including domain */
    username: string;
    /** The WebFinger account URI. Equal to `username` for local users, or `username@domain` for remote users. */
    acct: string;
    /** The location of the user's profile page. */
    url: string;
    /** The profile's display name. */
    displayName: string;
    /** The profile's bio / description. */
    note: string;
    /** An image icon that is shown next to statuses and in the profile. */
    avatar: string;
    /** A static version of the `avatar`. Equal to avatar if its value is a static image; different if `avatar` is an animated GIF. */
    avatarStatic: string;
    /** An image banner that is shown above the profile and in profile cards. */
    header: string;
    /** A static version of the header. Equal to `header` if its value is a static image; different if `header` is an animated GIF. */
    headerStatic: string;
    /** Whether the account manually approves follow requests. */
    locked: boolean;
    /** Custom emoji entities to be used when rendering the profile. If none, an empty array will be returned. */
    emojis: CustomEmoji[];
    /** Whether the account has opted into discovery features such as the profile directory. */
    discoverable: boolean;
    /** When the account was created. */
    createdAt: string;
    /** How many statuses are attached to this account. */
    statusesCount: number;
    /** The reported followers of this profile. */
    followersCount: number;
    /** The reported follows of this profile. */
    followingCount: number;
    /** Time of the last status posted */
    lastStatusAt: string;
    /** Indicates that the profile is currently inactive and that its user has moved to a new account. */
    moved?: Account$1 | null;
    /** An extra entity returned when an account is suspended. **/
    suspended?: boolean | null;
    /** Additional metadata attached to a profile as name-value pairs. */
    fields?: AccountField[] | null;
    /** Boolean to indicate that the account performs automated actions */
    bot?: boolean | null;
    /** Roles that have been granted to this account. */
    roles: Pick<Role, 'id' | 'name' | 'color'>[];
}
/**
 * @see https://docs.joinmastodon.org/entities/Account/#CredentialAccount
 */
interface AccountCredentials extends Account$1 {
    /**
     * Note the extra `source` property, which is not visible on accounts other than your own.
     * Also note that plain-text is used within `source` and HTML is used for their
     * corresponding properties such as `note` and `fields`.
     */
    source: AccountSource;
    /** The role assigned to the currently authorized user. */
    role: Role;
}

/**
 * Represents an IP address associated with a user.
 * @see https://docs.joinmastodon.org/entities/Admin_Ip/
 */
interface Ip {
    /** The IP address. */
    ip: string;
    /** The timestamp of when the IP address was last used for this account. */
    usedAt: string;
}

/**
 * Admin-level information about a given account.
 * @see https://docs.joinmastodon.org/entities/admin-account/
 */
interface Account {
    /** The ID of the account in the database. */
    id: string;
    /** The username of the account. */
    username: string;
    /** The domain of the account. */
    domain?: string | null;
    /** When the account was first discovered. */
    createdAt: string;
    /** The email address associated with the account. */
    email: string;
    /** The IP address last used to login to this account. */
    ip?: string | null;
    /** All known IP addresses associated with this account. */
    ips: Ip[];
    /** The locale of the account. */
    locale: string;
    /** The reason given when requesting an invite (for instances that require manual approval of registrations) */
    inviteRequest?: string | null;
    /** The current role of the account. */
    role: Role;
    /** Whether the account has confirmed their email address. */
    confirmed: boolean;
    /** Whether the account is currently approved. */
    approved: boolean;
    /** Whether the account is currently disabled. */
    disabled: boolean;
    /** Whether the account is currently silenced. */
    silenced: boolean;
    /** Whether the account is currently suspended. */
    suspended: boolean;
    /** Boolean. Filter for accounts force-marked as sensitive? */
    sensitized: boolean;
    /** User-level information about the account. */
    account: Account$1;
    /** The ID of the application that created this account. */
    createdByApplicationId?: string | null;
    /** The ID of the account that invited this user */
    invitedByAccountId?: string | null;
}

interface CanonicalEmailBlock {
    /** The ID of email block in the database. */
    id: string;
    /** The hash to test against. */
    canonicalEmailHash: string;
}

type CohortFrequency = 'day' | 'month';
interface CohortData {
    /** The timestamp for the start of the bucket, at midnight. */
    date: string;
    /** The percentage rate of users who registered in the specified `period` and were active for the given `date` bucket. */
    rate: number;
    /** How many users registered in the specified `period` and were active for the given `date` bucket. */
    value: number;
}
/**
 * Represents a retention metric.
 */
interface Cohort {
    /** The timestamp for the start of the period, at midnight. */
    period: string;
    /** The size of the bucket for the returned data. */
    frequency: CohortFrequency;
    /** Retention data for users who registered during the given period. */
    data: CohortData[];
}

interface DimensionData {
    /** The unique keystring for this data item. */
    key: string;
    /** A human-readable key for this data item. */
    humanKey: string;
    /** The value for this data item. */
    value: string;
    /** The units associated with this data item’s value, if applicable. */
    unit?: string | null;
    /** A human-readable formatted value for this data item. */
    humanValue?: string | null;
}
type DimensionKey = 'languages' | 'sources' | 'servers' | 'space_usage' | 'software_versions' | 'tag_servers' | 'tag_languages' | 'instance_accounts' | 'instance_languages';
/**
 * Represents qualitative data about the server.
 * @see https://docs.joinmastodon.org/entities/Admin_Dimension/
 */
interface Dimension {
    /** The unique keystring for the requested dimension. */
    key: DimensionKey;
    /** The data available for the requested dimension. */
    data: DimensionData[];
}

interface DomainAllow {
    /** The ID of the domain allow in the database. */
    id: string;
    /** The domain of the domain allow in the database. */
    domain: string;
    /** The create date of the domain allow in the database. */
    createdAt: string;
}

type DomainBlockSeverity = 'silence' | 'suspend' | 'noop';
interface DomainBlock {
    /** The ID of the domain block in the database. */
    id: string;
    /** The domain of the domain block in the database. */
    domain: string;
    /** The create date of the domain block in the database. */
    createdAt: string;
    /** The date of the application that created this account. */
    severity: DomainBlockSeverity;
    /** The reject media of the domain. */
    rejectMedia: boolean;
    /** The reject report of the domain. */
    rejectReposts: boolean;
    /** The private comment of the domain. */
    privateComment?: string | null;
    /** The public comment of the domain. */
    publicComment?: string | null;
    /** The obfuscate of the domain block. */
    obfuscate: boolean;
}

interface EmailDomainBlockHistory {
    /** UNIX timestamp on midnight of the given day. */
    day: string;
    /** The counted accounts signup attempts using that email domain within that day. */
    accounts: string;
    /** The counted IP signup attempts of that email domain within that day. */
    uses: string;
}
interface EmailDomainBlock {
    /** The ID of the email domain block in the database. */
    id: string;
    /** The domain of the email domain block in the database. */
    domain: string;
    /** The create date of the email domain block in the database. */
    createdAt: string;
    /** The history of the email domain block in the database. */
    history: EmailDomainBlockHistory[];
}

type IpBlockSeverity = 'sign_up_requires_approval' | 'sign_up_block' | 'no_access';
interface IpBlock {
    /** The ID of the domain allow in the database. */
    id: string;
    /** The IP address and prefix to block. */
    ip: string;
    /** The policy to apply to this IP range. */
    severity: IpBlockSeverity;
    /** The reason for this IP block. */
    comment: string;
    /** The create date of the ip block. */
    createdAt: string;
    /** The number of seconds in which this IP block will expire. */
    expiresAt: number | null;
}

interface MeasureData {
    /** Midnight on the requested day in the time period. */
    date: string;
    /** The numeric value for the requested measure. */
    value: string;
}
/** @see https://docs.joinmastodon.org/entities/Admin_Measure/#key */
type MeasureKey = 'active_users' | 'new_users' | 'interactions' | 'opened_reports' | 'resolved_reports' | 'tag_accounts' | 'tag_uses' | 'tag_servers' | 'instance_accounts' | 'instance_media_attachments' | 'instance_reports' | 'instance_statuses' | 'instance_follows' | 'instance_followers';
/**
 * Represents quantitative data about the server.
 * @see https://docs.joinmastodon.org/entities/Admin_Measure
 */
interface Measure {
    /** The unique keystring for the requested measure. */
    key: MeasureKey;
    /** The units associated with this data item’s value, if applicable. */
    unit?: string | null;
    /** The numeric total associated with the requested measure. */
    total: string;
    /** A human-readable formatted value for this data item. */
    humanValue?: string;
    /** The numeric total associated with the requested measure, in the previous period. Previous period is calculated by subtracting the start_at and end_at dates, then offsetting both start and end dates backwards by the length of the time period. */
    previousTotal?: string;
    /** The data available for the requested measure, split into daily buckets. */
    data: MeasureData[];
}

type ReportCategory$1 = 'spam' | 'violation' | 'other';
/**
 * Admin-level information about a filed report.
 * @see https://docs.joinmastodon.org/entities/admin-report/
 */
interface Report {
    /** The ID of the report in the database. */
    id: string;
    /** The action taken to resolve this report. */
    actionTaken: boolean;
    /** When an action was taken, if this report is currently resolved. */
    actionTakenAt?: string | null;
    /** The category under which the report is classified */
    category: ReportCategory$1;
    /** An optional reason for reporting. */
    comment: string;
    /** Whether a report was forwarded to a remote instance. */
    forwarded: boolean;
    /** The time the report was filed. */
    createdAt: string;
    /** The time of last action on this report. */
    updatedAt: string;
    /** The account which filed the report. */
    account: Account$1;
    /** The account being reported. */
    targetAccount: Account$1;
    /** The account of the moderator assigned to this report. */
    assignedAccount?: Account$1 | null;
    /** The action taken by the moderator who handled the report. */
    actionTakenByAccount: Account$1;
    /** Statuses attached to the report, for context. */
    statuses: Status[];
    /** Rules attached to the report, for context. */
    rules: Rule[];
}

interface TagHistory$1 {
    day: string;
    accounts: string;
    uses: string;
}
/**
 * @see https://docs.joinmastodon.org/entities/Tag/#admin
 */
interface Tag$1 {
    /** The ID of the Tag in the database. */
    id: string;
    name: string;
    url: string;
    history: TagHistory$1[];
    /** Whether the hashtag has been approved to trend. */
    trendable: boolean;
    /** Whether the hashtag has not been disabled from auto-linking. */
    usable: boolean;
    /** Whether the hashtag has not been reviewed yet to approve or deny its trending. */
    requiresReview: boolean;
}

type index$4_Account = Account;
type index$4_CanonicalEmailBlock = CanonicalEmailBlock;
type index$4_Cohort = Cohort;
type index$4_CohortData = CohortData;
type index$4_CohortFrequency = CohortFrequency;
type index$4_Dimension = Dimension;
type index$4_DimensionData = DimensionData;
type index$4_DimensionKey = DimensionKey;
type index$4_DomainAllow = DomainAllow;
type index$4_DomainBlock = DomainBlock;
type index$4_DomainBlockSeverity = DomainBlockSeverity;
type index$4_EmailDomainBlock = EmailDomainBlock;
type index$4_EmailDomainBlockHistory = EmailDomainBlockHistory;
type index$4_Ip = Ip;
type index$4_IpBlock = IpBlock;
type index$4_IpBlockSeverity = IpBlockSeverity;
type index$4_Measure = Measure;
type index$4_MeasureData = MeasureData;
type index$4_MeasureKey = MeasureKey;
type index$4_Report = Report;
declare namespace index$4 {
  export {
    index$4_Account as Account,
    index$4_CanonicalEmailBlock as CanonicalEmailBlock,
    index$4_Cohort as Cohort,
    index$4_CohortData as CohortData,
    index$4_CohortFrequency as CohortFrequency,
    index$4_Dimension as Dimension,
    index$4_DimensionData as DimensionData,
    index$4_DimensionKey as DimensionKey,
    index$4_DomainAllow as DomainAllow,
    index$4_DomainBlock as DomainBlock,
    index$4_DomainBlockSeverity as DomainBlockSeverity,
    index$4_EmailDomainBlock as EmailDomainBlock,
    index$4_EmailDomainBlockHistory as EmailDomainBlockHistory,
    index$4_Ip as Ip,
    index$4_IpBlock as IpBlock,
    index$4_IpBlockSeverity as IpBlockSeverity,
    index$4_Measure as Measure,
    index$4_MeasureData as MeasureData,
    index$4_MeasureKey as MeasureKey,
    index$4_Report as Report,
    ReportCategory$1 as ReportCategory,
    Tag$1 as Tag,
    TagHistory$1 as TagHistory,
  };
}

/**
 * Represents a weekly bucket of instance activity.
 * @see https://docs.joinmastodon.org/entities/activity/
 */
interface Activity {
    /** Midnight at the first day of the week. */
    week: string;
    /** Statuses created since the week began. */
    statuses: string;
    /** User logins since the week began. */
    logins: string;
    /** User registrations since the week began. */
    registrations: string;
}

interface AnnouncementAccount {
    id: string;
    username: string;
    url: string;
    acct: string;
}
interface AnnouncementStatus {
    id: string;
    url: string;
}
interface Announcement {
    id: string;
    content: string;
    startsAt: string;
    endsAt: string;
    allDay: boolean;
    publishedAt: string;
    updatedAt: string;
    mentions: AnnouncementAccount[];
    statuses: AnnouncementStatus[];
    tags: Tag[];
    emojis: CustomEmoji[];
    reactions: Reaction[];
}

/**
 * Represents an application that interfaces with the REST API to access accounts or post statuses.
 * @see https://docs.joinmastodon.org/entities/application/
 */
interface Application {
    /** The name of your application. */
    name: string;
    /** The website associated with your application. */
    website?: string | null;
    /** Used for Push Streaming API. Returned with POST /api/v1/apps. Equivalent to PushSubscription#server_key */
    vapidKey?: string | null;
}
interface Client$1 extends Application {
    /** Client ID key, to be used for obtaining OAuth tokens */
    clientId?: string | null;
    /** Client secret key, to be used for obtaining OAuth tokens */
    clientSecret?: string | null;
}

/**
 * Represents the tree around a given status. Used for reconstructing threads of statuses.
 * @see https://docs.joinmastodon.org/entities/context/
 */
interface Context {
    /** Parents in the thread. */
    ancestors: Status[];
    /** Children in the thread. */
    descendants: Status[];
}

/**
 * Represents a conversation with "direct message" visibility.
 * @see https://docs.joinmastodon.org/entities/conversation/
 */
interface Conversation {
    /** Local database ID of the conversation. */
    id: string;
    /** Participants in the conversation. */
    accounts: Account$1[];
    /** Is the conversation currently marked as unread? */
    unread: boolean;
    /** The last status in the conversation, to be used for optional display. */
    lastStatus?: Status | null;
}

/**
 * Represents a custom emoji.
 * @see https://docs.joinmastodon.org/entities/CustomEmoji/
 */
interface CustomEmoji {
    /** The name of the custom emoji. */
    shortcode: string;
    /** A link to the custom emoji. */
    url: string;
    /** A link to a static copy of the custom emoji. */
    staticUrl: string;
    /** Whether this Emoji should be visible in the picker or unlisted. */
    visibleInPicker: boolean;
    /** Used for sorting custom emoji in the picker. */
    category?: string | null;
}

/**
 * Represents a subset of your follows who also follow some other user.
 * @see https://docs.joinmastodon.org/entities/FamiliarFollowers/
 */
interface FamiliarFollowers {
    /** The ID of the Account in the database. */
    id: string;
    /** Accounts you follow that also follow this account. */
    accounts: Account$1[];
}

/**
 * Represents a hashtag that is featured on a profile.
 * @see https://docs.joinmastodon.org/entities/featuredtag/
 */
interface FeaturedTag {
    /** The internal ID of the featured tag in the database. */
    id: string;
    /** The name of the hashtag being featured. */
    name: string;
    /** The number of authored statuses containing this hashtag */
    statusesCount: number;
    /** The timestamp of the last authored status containing this hashtag. */
    lastStatusAt?: string | null;
}

type FilterContext$1 = 'home' | 'notifications' | 'public' | 'thread' | 'account';
/**
 * Represents a user-defined filter for determining which statuses should not be shown to the user.
 * @see https://docs.joinmastodon.org/entities/filter/
 */
interface Filter$1 {
    /** The ID of the filter in the database. */
    id: string;
    /** The text to be filtered. */
    phrase: string;
    /** The contexts in which the filter should be applied. */
    context: FilterContext$1[];
    /** When the filter should no longer be applied */
    expiresAt?: string | null;
    /** Should matching entities in home and notifications be dropped by the server? */
    irreversible: boolean;
    /** Should the filter consider word boundaries? */
    wholeWord: boolean;
}

/**
 * Represents a keyword that, if matched, should cause the filter action to be taken.
 * @see https://docs.joinmastodon.org/entities/FilterKeyword/
 */
interface FilterKeyword {
    /** The ID of the FilterKeyword in the database. */
    id: string;
    /** The phrase to be matched against. */
    keyword: string;
    /** Should the filter consider word boundaries? See [implementation guidelines](https://docs.joinmastodon.org/api/guidelines/#filters) for filters. */
    wholeWord: boolean;
}

/**
 * Represents a filter whose keywords matched a given status.
 * @see https://docs.joinmastodon.org/entities/FilterResult/
 */
interface FilterResult {
    /** The filter that was matched. */
    filter: Filter;
    /** The keyword within the filter that was matched. */
    keywordMatches: string[] | null;
    /** The status ID within the filter that was matched. */
    statusMatches: string[] | null;
}

/**
 * Represents a status ID that, if matched, should cause the filter action to be taken.
 * @see https://docs.joinmastodon.org/entities/FilterStatus/
 */
interface FilterStatus {
    /** The ID of the FilterStatus in the database. */
    id: string;
    /** The ID of the filtered Status in the database. */
    statusId: string;
}

/**
 * Represents a proof from an external identity provider.
 * @see https://docs.joinmastodon.org/entities/identityproof/
 */
interface IdentityProof {
    /** The name of the identity provider. */
    provider: string;
    /** The account owner's username on the identity provider's service. */
    providerUsername: string;
    /** The account owner's profile URL on the identity provider. */
    profileUrl: string;
    /** A link to a statement of identity proof, hosted by the identity provider. */
    proofUrl: string;
    /** The name of the identity provider. */
    updatedAt: string;
}

interface Rule {
    id: string;
    text: string;
}

interface InstanceStatusesConfiguration$1 {
    maxCharacters: number;
    maxMediaAttachments: number;
    charactersReservedPerUrl: string;
}
interface InstanceMediaAttachmentsConfiguration$1 {
    supportedMimeTypes: string[];
    imageSizeLimit: number;
    imageMatrixLimit: number;
    videoSizeLimit: number;
    videoFrameRateLimit: number;
    videoMatrixLimit: number;
}
interface InstancePollsConfiguration$1 {
    maxOptions: number;
    maxCharactersPerOption: number;
    minExpiration: number;
    maxExpiration: number;
}
interface InstanceAccountsConfiguration$1 {
    maxFeaturedTags: number;
}
/**
 * @see https://github.com/mastodon/mastodon/pull/16485
 */
interface InstanceConfiguration$1 {
    statuses: InstanceStatusesConfiguration$1;
    mediaAttachments: InstanceMediaAttachmentsConfiguration$1;
    polls: InstancePollsConfiguration$1;
    accounts: InstanceAccountsConfiguration$1;
}
/**
 * Represents the software instance of Mastodon running on this domain.
 * @see https://docs.joinmastodon.org/entities/instance/
 */
interface Instance$1 {
    /** The domain name of the instance. */
    uri: string;
    /** The title of the website. */
    title: string;
    /** Admin-defined description of the Mastodon site. */
    description: string;
    /** A shorter description defined by the admin. */
    shortDescription: string;
    /** An email that may be contacted for any inquiries. */
    email: string;
    /** The version of Mastodon installed on the instance. */
    version: string;
    /** Primary languages of the website and its staff. */
    languages: string[];
    /** Whether registrations are enabled. */
    registrations: boolean;
    /** Whether registrations require moderator approval. */
    approvalRequired: boolean;
    /** URLs of interest for clients apps. */
    urls: InstanceURLs;
    /** Statistics about how much information the instance contains. */
    stats: InstanceStats;
    /** Whether invitation in enabled */
    invitesEnabled: boolean;
    /** List various values like file size limits and supported mime types */
    configuration: InstanceConfiguration$1;
    /** Banner image for the website. */
    thumbnail?: string | null;
    /** A user that can be contacted, as an alternative to `email`. */
    contactAccount?: Account$1 | null;
    rules?: Rule[] | null;
}
interface InstanceURLs {
    /** WebSockets address for push streaming. String (URL). */
    streamingApi: string;
}
interface InstanceStats {
    /** Users registered on this instance. Number. */
    userCount: number;
    /** Statuses authored by users on instance. Number. */
    statusCount: number;
    /** Domains federated with this instance. Number. */
    domainCount: number;
}

type ListRepliesPolicy = 'followed' | 'list' | 'none';
/**
 * Represents a list of some users that the authenticated user follows.
 * @see https://docs.joinmastodon.org/entities/list/
 */
interface List {
    /** The internal database ID of the list. */
    id: string;
    /** The user-defined title of the list. */
    title: string;
    /**
     * Which replies should be shown in the list.
     *
     * `followed` = Show replies to any followed user
     *
     * `list` = Show replies to members of the list
     *
     * `none` = Show replies to no one
     */
    repliesPolicy: ListRepliesPolicy;
}

interface MarkerItem {
    /** The ID of the most recently viewed entity. */
    lastReadId: string;
    /** The timestamp of when the marker was set. */
    updatedAt: string;
    /** Used for locking to prevent write conflicts. */
    version: number;
}
type MarkerTimeline = 'home' | 'notifications';
/**
 * Represents the last read position within a user's timelines.
 * @see https://docs.joinmastodon.org/entities/marker/
 */
type Marker = {
    [key in MarkerTimeline]: MarkerItem;
};

type MediaAttachmentType = 'image' | 'video' | 'gifv' | 'audio' | 'unknown';
interface MediaAttachmentMetaImage {
    width: number;
    height: number;
    size: string;
    aspect: number;
}
interface MediaAttachmentMetaVideo {
    width: number;
    height: number;
    frameRate: string;
    duration: number;
    bitrate: number;
    aspect: number;
}
interface MediaAttachmentMetaFocus {
    x: number;
    y: number;
}
interface MediaAttachmentMetaColors {
    background: string;
    foreground: string;
    accent: string;
}
interface MediaAttachmentMeta {
    small?: MediaAttachmentMetaImage | MediaAttachmentMetaVideo | null;
    original?: MediaAttachmentMetaImage | MediaAttachmentMetaVideo | null;
    focus?: MediaAttachmentMetaFocus | null;
    colors?: MediaAttachmentMetaColors | null;
}
/**
 * Represents a file or media MediaAttachment that can be added to a status.
 * @see https://docs.joinmastodon.org/entities/MediaAttachment/
 */
interface MediaAttachment {
    /** The ID of the MediaAttachment in the database. */
    id: string;
    /** The type of the MediaAttachment. */
    type: MediaAttachmentType;
    /** The location of the original full-size MediaAttachment. */
    url?: string | null;
    /** The location of a scaled-down preview of the MediaAttachment. */
    previewUrl: string;
    /** The location of the full-size original MediaAttachment on the remote website. */
    remoteUrl?: string | null;
    /** Remote version of previewUrl */
    previewRemoteUrl?: string | null;
    /** A shorter URL for the MediaAttachment. */
    textUrl?: string | null;
    /** Metadata returned by Paperclip. */
    meta?: MediaAttachmentMeta | null;
    /**
     * Alternate text that describes what is in the media MediaAttachment,
     * to be used for the visually impaired or when media MediaAttachments do not load.
     */
    description?: string | null;
    /**
     * A hash computed by the BlurHash algorithm,
     * for generating colorful preview thumbnails when media has not been downloaded yet.
     */
    blurhash?: string | null;
}

/**
 * Represents a mention of a user within the content of a status.
 * @see https://docs.joinmastodon.org/entities/mention/
 */
interface StatusMention {
    /** The account id of the mentioned user. */
    id: string;
    /** The username of the mentioned user. */
    username: string;
    /** The location of the mentioned user's profile. */
    url: string;
    /**
     * The WebFinger acct: URI of the mentioned user.
     * Equivalent to username for local users, or `username@domain` for remote users.
     */
    acct: string;
}
type StatusVisibility = 'public' | 'unlisted' | 'private' | 'direct';
/**
 * Represents a status posted by an account.
 * @see https://docs.joinmastodon.org/entities/status/
 */
interface Status {
    /** ID of the status in the database. */
    id: string;
    /** URI of the status used for federation. */
    uri: string;
    /** The date when this status was created. */
    createdAt: string;
    /** Timestamp of when the status was last edited. */
    editedAt: string | null;
    /** The account that authored this status. */
    account: Account$1;
    /** HTML-encoded status content. */
    content: string;
    /** Visibility of this status. */
    visibility: StatusVisibility;
    /** Is this status marked as sensitive content? */
    sensitive: boolean;
    /** Subject or summary line, below which status content is collapsed until expanded. */
    spoilerText: string;
    /** Media that is attached to this status. */
    mediaAttachments: MediaAttachment[];
    /** The application used to post this status. */
    application: Application;
    /** Mentions of users within the status content. */
    mentions: StatusMention[];
    /** Hashtags used within the status content. */
    tags: Tag[];
    /** Custom emoji to be used when rendering status content. */
    emojis: CustomEmoji[];
    /** How many boosts this status has received. */
    reblogsCount: number;
    /** How many favourites this status has received. */
    favouritesCount: number;
    /** If the current token has an authorized user: The filter and keywords that matched this status. */
    filtered?: FilterResult[];
    /** How many replies this status has received. */
    repliesCount: number;
    /** A link to the status's HTML representation. */
    url?: string | null;
    /** ID of the status being replied. */
    inReplyToId?: string | null;
    /** ID of the account being replied to. */
    inReplyToAccountId?: string | null;
    /** The status being reblogged. */
    reblog?: Status | null;
    /** The poll attached to the status. */
    poll?: Poll | null;
    /** Preview card for links included within status content. */
    card?: PreviewCard | null;
    /** Primary language of this status. */
    language?: string | null;
    /**
     * Plain-text source of a status. Returned instead of `content` when status is deleted,
     * so the user may redraft from the source text without the client having
     * to reverse-engineer the original text from the HTML content.
     */
    text?: string | null;
    /** Have you favourited this status? */
    favourited?: boolean | null;
    /** Have you boosted this status? */
    reblogged?: boolean | null;
    /** Have you muted notifications for this status's conversation? */
    muted?: boolean | null;
    /** Have you bookmarked this status? */
    bookmarked?: boolean | null;
    /** Have you pinned this status? Only appears if the status is pin-able. */
    pinned?: boolean | null;
}

type NotificationType = 'mention' | 'status' | 'reblog' | 'follow' | 'follow_request' | 'favourite' | 'poll' | 'update' | 'admin.sign_up' | 'admin.report';
/**
 * Represents a notification of an event relevant to the user.
 * @see https://docs.joinmastodon.org/entities/notification
 */
interface Notification {
    /** The id of the notification in the database. */
    id: string;
    /** The type of event that resulted in the notification. */
    type: NotificationType;
    /** The timestamp of the notification. */
    createdAt: string;
    /** The account that performed the action that generated the notification. */
    account: Account$1;
    /** Status that was the object of the notification, e.g. in mentions, reblogs, favourites, or polls. */
    status?: Status | null;
}

interface PollOption {
    /** The text value of the poll option. String. */
    title: string;
    /** The number of received votes for this option. Number, or null if results are not published yet. */
    votesCount?: number;
    /** Custom emoji to be used for rendering poll options. */
    emojis: CustomEmoji[];
}
/**
 * Represents a poll attached to a status.
 * @see https://docs.joinmastodon.org/entities/poll/
 */
interface Poll {
    /** The ID of the poll in the database. */
    id: string;
    /** When the poll ends. */
    expiresAt?: string | null;
    /** Is the poll currently expired? */
    expired: boolean;
    /** Does the poll allow multiple-choice answers? */
    multiple: boolean;
    /** How many votes have been received. */
    votesCount: number;
    /** How many unique accounts have voted on a multiple-choice poll. */
    votersCount?: number | null;
    /** When called with a user token, has the authorized user voted? */
    voted?: boolean;
    /**
     * When called with a user token, which options has the authorized user chosen?
     * Contains an array of index values for options.
     */
    ownVotes?: number[] | null;
    /** Possible answers for the poll. */
    options: PollOption[];
}

type PreferenceReadingExpandMedia = 'show_all' | 'hide_all' | 'default';
/**
 * Represents a user's preferences.
 * @see https://docs.joinmastodon.org/entities/preferences/
 */
interface Preference {
    /** Default visibility for new posts. Equivalent to Source#privacy. */
    'posting:default:visibility': StatusVisibility;
    /** Default sensitivity flag for new posts. Equivalent to Source#sensitive. */
    'posting:default:sensitive': boolean;
    /** Default language for new posts. Equivalent to Source#language */
    'posting:default:language': string;
    /** Whether media attachments should be automatically displayed or blurred/hidden. */
    'reading:expand:media': PreferenceReadingExpandMedia;
    /** Whether CWs should be expanded by default. */
    'reading:expand:spoilers': boolean;
    /** Whether GIFs should be automatically played */
    'reading:autoplay:gifs': boolean;
}

/**
 * Represents daily usage history of a hashtag.
 */
interface TagHistory {
    /** UNIX timestamp on midnight of the given day. */
    day: string;
    /** the counted usage of the tag within that day. */
    uses: string;
    /** the total of accounts using the tag within that day. */
    accounts: string;
}
/**
 * Represents a hashtag used within the content of a status.
 * @see https://docs.joinmastodon.org/entities/tag/
 */
interface Tag {
    /** The value of the hashtag after the # sign. */
    name: string;
    /** A link to the hashtag on the instance. */
    url: string;
    /** Usage statistics for given days. */
    history?: TagHistory[] | null;
    /** Whether the current token’s authorized user is following this tag. */
    following?: boolean | null;
}

type PreviewCardType = 'link' | 'photo' | 'video' | 'rich';
/**
 * Represents a rich preview card that is generated using OpenGraph tags from a URL.
 * @see https://docs.joinmastodon.org/entities/PreviewCard
 */
interface PreviewCard {
    /** Location of linked resource. */
    url: string;
    /** Title of linked resource. */
    title: string;
    /** Description of preview. */
    description: string;
    /** The type of the preview card. */
    type: PreviewCardType;
    /** Blurhash */
    blurhash: string;
    /** The author of the original resource. */
    authorName?: string | null;
    /** A link to the author of the original resource. */
    authorUrl?: string | null;
    /** The provider of the original resource. */
    providerName?: string | null;
    /** A link to the provider of the original resource. */
    providerUrl?: string | null;
    /** HTML to be used for generating the preview card. */
    html?: string | null;
    /** Width of preview, in pixels. */
    width?: number | null;
    /** Height of preview, in pixels. */
    height?: number | null;
    /** Preview thumbnail. */
    image?: string | null;
    /** Used for photo embeds, instead of custom `html`. */
    embedUrl: string;
}
interface TrendLink extends PreviewCard {
    history: TagHistory[];
}

interface Reaction {
    name: string;
    count: number;
    me: boolean;
    url: string;
    staticUrl: string;
}

/**
 * Represents the relationship between accounts, such as following / blocking / muting / etc.
 * @see https://docs.joinmastodon.org/entities/relationship/
 */
interface Relationship {
    /** The account id. */
    id: string;
    /** Are you following this user? */
    following: boolean;
    /** Are you receiving this user's boosts in your home timeline? */
    showingReblogs: boolean;
    /** Have you enabled notifications for this user? */
    notifying: boolean;
    /** Which languages are you following from this user? */
    languages: string[];
    /** Are you followed by this user? */
    followedBy: boolean;
    /** Are you blocking this user? */
    blocking: boolean;
    /** Is this user blocking you? */
    blockedBy: boolean;
    /** Are you muting this user? */
    muting: boolean;
    /** Are you muting notifications from this user? */
    mutingNotifications: boolean;
    /** Do you have a pending follow request for this user? */
    requested: boolean;
    /** Are you blocking this user's domain? */
    domainBlocking: boolean;
    /** Are you featuring this user on your profile? */
    endorsed: boolean;
    /** Personal note for this account */
    note?: string | null;
    /** Whether the represented user has requested to follow you */
    requestedBy: boolean;
}

/**
 * Represents a custom user role that grants permissions.
 * @see https://docs.joinmastodon.org/entities/Role/
 */
interface Role {
    /** The ID of the Role in the database. */
    id: number;
    /** The name of the role. */
    name: string;
    /** The hex code assigned to this role. If no hex code is assigned, the string will be empty */
    color: string;
    /** An index for the role’s position. The higher the position, the more priority the role has over other roles. */
    position: number;
    /** A bitmask that represents the sum of all permissions granted to the role. */
    permissions: number;
    /** Whether the role is publicly visible as a badge on user profiles. */
    highlighted: boolean;
    /** The date that the role was created. */
    createdAt: string;
    /** The date that the role was updated. */
    updatedAt: string;
}

interface StatusParams extends Pick<Status, 'id' | 'inReplyToId' | 'sensitive' | 'spoilerText' | 'visibility'> {
    /** Content of the status */
    text: string;
    /** IDs of media attachments */
    mediaIds?: string[] | null;
    /** ID of the application */
    applicationId: string;
}
/**
 * Represents a status that will be published at a future scheduled date.
 * @see https://docs.joinmastodon.org/entities/scheduledstatus/
 */
interface ScheduledStatus {
    /** ID of the scheduled status in the database. */
    id: string;
    /** ID of the status in the database. */
    scheduledAt: string;
    /** Parameters of the status */
    params: StatusParams;
    /** Media attachments */
    mediaAttachments: MediaAttachment[];
}

/**
 * Represents the results of a search.
 * @see https://docs.joinmastodon.org/entities/results/
 */
interface Search$1 {
    /** Accounts which match the given query */
    accounts: Account$1[];
    /** Statuses which match the given query */
    statuses: Status[];
    /** Hashtags which match the given query */
    hashtags: string[];
}

type StatusEdit = Pick<Status, 'content' | 'spoilerText' | 'sensitive' | 'createdAt' | 'account' | 'mediaAttachments' | 'emojis'>;

interface StatusSource {
    id: string;
    text: string;
    spoilerText: string;
}

type SuggestionSource = 'staff' | 'past_interactions' | 'global';
/**
 * Represents a suggested account to follow and an associated reason for the suggestion.
 * @see https://docs.joinmastodon.org/entities/Suggestion/
 */
interface Suggestion {
    /**
     * The reason this account is being suggested.
     * `staff` = This account was manually recommended by your administration team
     * `past_interactions` = You have interacted with this account previously
     * `global` = This account has many reblogs, favourites, and active local followers within the last 30 days
     */
    source: SuggestionSource;
    /**
     * The account being recommended to follow.
     */
    account: Account$1;
}

/**
 * Represents an OAuth token used for authenticating with the API and performing actions.
 * @see https://docs.joinmastodon.org/entities/token/
 */
interface Token {
    /** An OAuth token to be used for authorization. */
    accessToken: string;
    /** The OAuth token type. Mastodon uses Bearer tokens. */
    tokenType: string;
    /** The OAuth scopes granted by this token, space-separated. */
    scope: string;
    /** When the token was generated. */
    createdAt: number;
}

interface Translation {
    /** The translated text of the status. */
    content: string;
    /** The language of the source text, as auto-detected by the machine translation provider. */
    detectedLanguageSource: string;
    /** The service that provided the machine translation. */
    provider: string;
}

type WebPushSubscriptionPolicy = 'all' | 'followed' | 'follower' | 'none';
/** @deprecated Use WebPushSubscriptionPolicy */
type SubscriptionPolicy = WebPushSubscriptionPolicy;
/**
 * Represents a subscription to the push streaming server.
 * @see https://docs.joinmastodon.org/entities/WebPushSubscription/
 */
interface WebPushSubscription {
    /** The id of the push subscription in the database. */
    id: string;
    /** Where push alerts will be sent to. */
    endpoint: string;
    /** The streaming server's VAPID key. */
    serverKey: string;
    /** Which alerts should be delivered to the `endpoint`. */
    alerts: WebPushSubscriptionAlerts;
    policy: WebPushSubscriptionPolicy;
}
interface WebPushSubscriptionAlerts {
    /** Receive a push notification when someone has followed you? Boolean. */
    follow: boolean;
    /** Receive a push notification when a status you created has been favourited by someone else? Boolean. */
    favourite: boolean;
    /** Receive a push notification when someone else has mentioned you in a status? Boolean. */
    reblog: boolean;
    /** Receive a push notification when a status you created has been boosted by someone else? Boolean. */
    mention: boolean;
    /** Receive a push notification when a poll you voted in or created has ended? Boolean. */
    poll: boolean;
    /** Receive new subscribed account notifications? Defaults to false. */
    status: boolean;
    /** Receive status edited notifications? Defaults to false. */
    update: boolean;
    admin: {
        /** Receive new user signup notifications? Defaults to false. Must have a role with the appropriate permissions. */
        signUp: boolean;
        /** Receive new report notifications? Defaults to false. Must have a role with the appropriate permissions. */
        report: boolean;
    };
}

declare class Paginator<Entity, Params = never> implements AsyncIterableIterator<Entity>, PromiseLike<Entity> {
    private readonly http;
    private nextPath?;
    private nextParams?;
    constructor(http: Http, nextPath?: string | undefined, nextParams?: Params | undefined);
    next(): Promise<IteratorResult<Entity, undefined>>;
    return(value?: undefined | Promise<undefined>): Promise<IteratorResult<Entity, undefined>>;
    throw(e: unknown): Promise<IteratorResult<Entity, undefined>>;
    then<TResult1 = Entity, TResult2 = never>(onfulfilled?: (value: Entity) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: unknown) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2>;
    [Symbol.asyncIterator](): AsyncGenerator<Entity, undefined, Params | undefined>;
    private clear;
    private pluckNext;
    clone(): Paginator<Entity, Params>;
}

interface DefaultPaginationParams {
    /** Return results older than this ID. */
    readonly maxId?: string | null;
    /** Return results newer than this ID. */
    readonly sinceId?: string | null;
    /** Get a list of items with ID greater than this value excluding this ID */
    readonly minId?: string | null;
    /** Maximum number of results to return per page. Defaults to 40. NOTE: Pagination is done with the Link header from the response. */
    readonly limit?: number | null;
}
interface Repository<Entity, CreateParams = never, UpdateParams = never, FetchParams = never, ListParams = undefined> {
    readonly fetch?: ((id: string) => Promise<Entity>) | ((params?: FetchParams) => Promise<Entity>);
    readonly list?: ListParams extends undefined ? () => Paginator<Entity[]> : (params?: ListParams) => Paginator<Entity[], ListParams>;
    readonly create?: (params: CreateParams) => Promise<Entity>;
    readonly update?: ((id: string, params: UpdateParams) => Promise<Entity>) | ((params: UpdateParams) => Promise<Entity>);
    readonly remove?: ((id: string) => Promise<void>) | ((id: string) => Promise<Entity>);
}

interface CreateAccountParams {
    /** The desired username for the account */
    readonly username: string;
    /** The password to be used for login */
    readonly password: string;
    /** The email address to be used for login */
    readonly email: string;
    /** Whether the user agrees to the local rules, terms, and policies. These should be presented to the user in order to allow them to consent before setting this parameter to TRUE. */
    readonly agreement: boolean;
    /** The language of the confirmation email that will be sent */
    readonly locale: string;
    /** Text that will be reviewed by moderators if registrations require manual approval. */
    readonly reason?: string;
}
interface UpdateCredentialsParams {
    /** Whether the account should be shown in the profile directory. */
    readonly discoverable?: boolean;
    /** Whether the account has a bot flag. */
    readonly bot?: boolean;
    /** The display name to use for the profile. */
    readonly displayName?: string | null;
    /** The account bio. */
    readonly note?: string | null;
    /** Avatar image encoded using multipart/form-data */
    readonly avatar?: unknown;
    /** Header image encoded using multipart/form-data */
    readonly header?: unknown;
    /** Whether manual approval of follow requests is required. */
    readonly locked?: boolean | null;
    readonly source?: Partial<Pick<AccountSource, 'privacy' | 'sensitive' | 'language'>> | null;
    /** Whether you want to hide followers and followings on your profile  */
    readonly hideCollections?: boolean | null;
    /**
     * Profile metadata `name` and `value`.
     * (By default, max 4 fields and 255 characters per property/value)
     */
    readonly fieldsAttributes?: AccountField[] | null;
}
interface MuteAccountParams {
    /** Mute notifications in addition to statuses? Defaults to true. */
    readonly notifications?: boolean;
}
interface CreateAccountNoteParams {
    readonly comment: string;
}
interface ListAccountStatusesParams extends DefaultPaginationParams {
    /** Only return statuses that have media attachments */
    readonly onlyMedia?: boolean | null;
    /** Only return statuses that have been pinned */
    readonly pinned?: boolean | null;
    /** Skip statuses that reply to other statuses */
    readonly excludeReplies?: boolean | null;
    /** Skip statuses that are boosts of other statuses */
    readonly excludeReblogs?: boolean | null;
    /** Only return statuses using a specific hashtag */
    readonly tagged?: string | null;
}
interface FollowAccountParams {
    /** Receive this account's reblogs in home timeline? Defaults to true */
    readonly reblogs?: boolean | null;
    /** Receive notifications when this account posts a status? Defaults to false */
    readonly notify?: boolean | null;
    /** Array of String (ISO 639-1 language two-letter code). Filter received statuses for these languages. If not provided, you will receive this account's posts in all languages */
    readonly languages?: string[] | null;
}
interface SearchAccountsParams {
    /** What to search for */
    readonly q: string;
    /** Maximum number of results. Defaults to 40. */
    readonly limit?: number | null;
    /** Attempt WebFinger lookup. Defaults to false. Use this when `q` is an exact address. */
    readonly resolve?: boolean | null;
    /** Only who the user is following. Defaults to false. */
    readonly following?: boolean | null;
}
interface LookupAccountParams {
    readonly acct: string;
}
declare class AccountRepository$1 {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View information about a profile.
     * @param id The id of the account in the database
     * @return Account
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    fetch(id: string): Promise<Account$1>;
    /**
     * Creates a user and account records. Returns an account access token
     * for the app that initiated the request. The app should save this token for later,
     * and should wait for the user to confirm their account by clicking a link in their email inbox.
     * @param params Parameters
     * @return Token
     * @see https://docs.joinmastodon.org/methods/accounts/#create
     */
    create(params: CreateAccountParams): Promise<Token>;
    /**
     * Test to make sure that the user token works.
     * @return the user's own Account with Source
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    verifyCredentials(): Promise<AccountCredentials>;
    /**
     *  Update the user's display and preferences.
     * @param params Parameters
     * @return the user's own Account with Source
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    updateCredentials(params?: UpdateCredentialsParams): Promise<AccountCredentials>;
    /**
     * Accounts which follow the given account, if network is not hidden by the account owner.
     * @param id The id of the account in the database
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    listFollowers(id: string, params?: DefaultPaginationParams): Paginator<Account$1[], DefaultPaginationParams>;
    /**
     * Accounts which the given account is following, if network is not hidden by the account owner.
     * @param id The id of the account in the database
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    listFollowing(id: string, params?: DefaultPaginationParams): Paginator<Account$1[], DefaultPaginationParams>;
    /**
     * Statuses posted to the given account.
     * @param id The id of the account in the database
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    listStatuses(id: string, params?: ListAccountStatusesParams): Paginator<Status[], ListAccountStatusesParams>;
    /**
     * Follow the given account.
     * @param id The id of the account in the database
     * @param params Parameters
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    follow(id: string, params?: FollowAccountParams): Promise<Relationship>;
    /**
     * Unfollow the given account
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    unfollow(id: string, params?: FollowAccountParams): Promise<Relationship>;
    /**
     * Find out whether a given account is followed, blocked, muted, etc.
     * @param id Array of account IDs to check
     * @return Array of Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    fetchRelationships(id: readonly string[]): Promise<Relationship[]>;
    /**
     * Search for matching accounts by username or display name.
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    search(params?: SearchAccountsParams): Paginator<Account$1[], SearchAccountsParams>;
    /**
     * Block the given account. Clients should filter statuses from this account if received (e.g. due to a boost in the Home timeline)
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    block(id: string): Promise<Relationship>;
    /**
     * Unblock the given account.
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    unblock(id: string): Promise<Relationship>;
    /**
     * Add the given account to the user's featured profiles. (Featured profiles are currently shown on the user's own public profile.)
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts#pin
     */
    pin(id: string): Promise<Relationship>;
    /**
     * Remove the given account from the user's featured profiles.
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    unpin(id: string): Promise<Relationship>;
    /**
     * Fetch the list with the given ID. Used for verifying the title of a list.
     * @param id ID of the list in the database
     * @return Array of List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    listLists(id: string): Paginator<List[]>;
    /**
     * Mute the given account. Clients should filter statuses and notifications from this account, if received (e.g. due to a boost in the Home timeline).
     * @param id The id of the account in the database
     * @param params Parameter
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    mute(id: string, params?: MuteAccountParams): Promise<Relationship>;
    /**
     * Unmute the given account.
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    unmute(id: string): Promise<Relationship>;
    /**
     * Add personal note to the account
     * @param id ID of the account
     * @param param Parameters
     * @return Relationship
     */
    createNote(id: string, params: CreateAccountNoteParams): Promise<Relationship>;
    /**
     * Get featured tag of the account
     * @param id ID of the account
     * @return FeaturedTags
     */
    listFeaturedTags(id: string): Paginator<FeaturedTag[]>;
    /**
     * Identity proofs
     * @param id The id of the account in the database
     * @return Array of IdentityProof
     * @see https://github.com/tootsuite/mastodon/pull/10297
     */
    listIdentityProofs(id: string): Paginator<IdentityProof[]>;
    /**
     * This method allows to quickly convert a username of a known account to an ID that can be used with the REST API, or to check if a username is available for sign-up
     * @param params Parameters
     * @return Account
     */
    lookup(params: LookupAccountParams): Promise<Account$1>;
    /**
     * Obtain a list of all accounts that follow a given account, filtered for accounts you follow.
     * @returns Array of FamiliarFollowers
     */
    fetchFamiliarFollowers(id: string[]): Promise<FamiliarFollowers[]>;
    /**
     * @param id ID of the account
     * @returns N/A
     */
    removeFromFollowers(id: string): Promise<void>;
}

/**
 * Map of event name and callback argument
 * @see https://docs.joinmastodon.org/methods/streaming/#events
 */
interface EventTypeMap {
    /** A new Status has appeared. Payload contains a Status cast to a string. Available since v1.0.0 */
    update: [Status];
    /** A status has been deleted. Payload contains the String ID of the deleted Status. Available since v1.0.0 */
    delete: [Status['id']];
    /** A new notification has appeared. Payload contains a Notification cast to a string. Available since v1.4.2 */
    notification: [Notification];
    /** Keyword filters have been changed. Either does not contain a payload (for WebSocket connections), or contains an undefined payload (for HTTP connections). Available since v2.4.3 */
    filters_changed: [];
    /** A direct conversation has been updated. Payload contains a Conversation cast to a string. Available since v2.6.0 */
    conversation: [Conversation];
    /** A Status has been edited. Payload contains a Status cast to a string. Available since v3.5.0 */
    'status.update': [Status];
    /** An announcement has been published. Payload contains an Announcement cast to a string. Available since v3.1.0 */
    announcement: [Announcement];
    /** An announcement has received an emoji reaction. Payload contains a Hash (with name, count, and announcement_id) cast to a string. Available since v3.1.0 */
    'announcement.reaction': [Reaction];
    /** An announcement has been deleted. Payload contains the String ID of the deleted Announcement. Available since v3.1.0 */
    'announcement.delete': [Announcement['id']];
}
/** Supported event names */
type EventType = keyof EventTypeMap;
/** Mastodon event */
interface Event {
    event: EventType;
    payload: string;
}
type WsEventHandler<T extends EventType> = (...data: EventTypeMap[T]) => unknown;
interface WsEvents extends Omit<EventEmitter<EventTypeMap>, 'on'> {
    readonly disconnect: () => void;
    readonly on: <T extends EventType>(name: T, cb: WsEventHandler<T>) => void;
}
interface Ws {
    stream(path: string, params: unknown): Promise<WsEvents>;
}

/**
 * Mastodon streaming api wrapper
 */
declare class WsEventsNativeImpl extends EventEmitter<EventTypeMap> implements WsEvents {
    private readonly ws;
    private readonly serializer;
    private readonly logger;
    constructor(ws: WebSocket, serializer: Serializer, logger: Logger);
    /**
     * Connect to the websocket endpoint
     * @param url URL of the websocket endpoint
     * @param protocols Subprotocol(s) for `Sec-Websocket-Protocol`
     * @param params URL parameters
     */
    static connect(url: string, serializer: Serializer, logger: Logger, protocols?: string | string[]): Promise<WsEvents>;
    /**
     * Disconnect from the websocket endpoint
     */
    disconnect(): void;
    /**
     * Parse JSON data and emit it as an event
     * @param message Websocket message
     */
    private handleMessage;
}
declare class WsNativeImpl implements Ws {
    private readonly config;
    private readonly serializer;
    private readonly logger;
    constructor(config: MastoConfig, serializer: Serializer, logger: Logger);
    stream(path: string, params?: Record<string, unknown>): Promise<WsEvents>;
}

declare class StreamRepository {
    private readonly ws;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(ws: Ws, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Starting home timeline and notification streaming
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamUser(): Promise<WsEvents>;
    /**
     * Starting federated timeline streaming
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamPublicTimeline(): Promise<WsEvents>;
    /**
     * Starting local timeline streaming
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamCommunityTimeline(): Promise<WsEvents>;
    /**
     * Stream remote public timeline
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamRemotePublicTimeline(): Promise<WsEvents>;
    /**
     * Starting tag timeline streaming
     * @param id ID of the tag
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamTagTimeline(id: string): Promise<WsEvents>;
    /**
     * Starting local tag timeline streaming
     * @param id ID of the tag
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamLocalTagTimeline(id: string): Promise<WsEvents>;
    /**
     * Starting list timeline streaming
     * @param id ID of the list
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamListTimeline(id: string): Promise<WsEvents>;
    /**
     * Starting direct timeline streaming
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamDirectTimeline(): Promise<WsEvents>;
}

declare class AnnouncementRepository implements Repository<Announcement, never, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Fetch announcements
     * @return Announcements
     * @see https://docs.joinmastodon.org/methods/announcements/
     */
    list(): Paginator<Announcement[]>;
    /**
     * Dismiss announcement
     * @param id ID of the announcement
     * @return Nothing
     * @see https://docs.joinmastodon.org/methods/announcements/
     */
    dismiss(id: string): Promise<void>;
    /**
     * Add a reaction to an announcement
     * @param id ID of the announcement
     * @param name Emoji string
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/announcements/
     */
    addReaction(id: string, name: string): Promise<void>;
    /**
     * Remove a reaction from an announcement
     * @param id ID of the announcement
     * @param name Emoji string
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/announcements/
     */
    removeReaction(id: string, name: string): Promise<void>;
}

interface CreateAppParams {
    /** A name of your application */
    readonly clientName: string;
    /**
     * Where the user should be redirected after authorization.
     * To display the authorization code to the user instead of redirecting to a web page,
     * use `urn:ietf:wg:oauth:2.0:oob` in this parameter.
     */
    readonly redirectUris: string;
    /** Space separated list of scopes. If none is provided, defaults to `read`. */
    readonly scopes: string;
    /** URL to the homepage of your app */
    readonly website?: string | null;
}
declare class AppRepository implements Repository<Client$1, CreateAppParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Create a new application to obtain OAuth2 credentials.
     * @param params Parameters
     * @return Returns App with `client_id` and `client_secret`
     * @see https://docs.joinmastodon.org/methods/apps/
     */
    create(params: CreateAppParams): Promise<Client$1>;
    /**
     * Confirm that the app's OAuth2 credentials work.
     * @return Application
     * @see https://docs.joinmastodon.org/methods/apps/
     */
    verifyCredentials(): Promise<Client$1>;
}

declare class BlockRepository implements Repository<Account$1, never, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Blocked users
     * @param params Array of Account
     * @return Query parameter
     * @see https://docs.joinmastodon.org/methods/accounts/blocks/
     */
    list(params?: DefaultPaginationParams): Paginator<Account$1[], DefaultPaginationParams>;
}

declare class BookmarkRepository implements Repository<Status, never, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Statuses the user has bookmarked.
     * @param params Parameters
     * @return Array of Statuses
     * @see https://docs.joinmastodon.org/methods/accounts/bookmarks/
     */
    list(params?: DefaultPaginationParams): Paginator<Status[], DefaultPaginationParams>;
}

declare class ConversationRepository implements Repository<Conversation, never, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Show conversation
     * @param params Parameters
     * @return Array of Conversation
     * @see https://docs.joinmastodon.org/methods/timelines/conversations/
     */
    list(params?: DefaultPaginationParams): Paginator<Conversation[], DefaultPaginationParams>;
    /**
     * Remove conversation
     * @param id ID of the conversation in the database
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/timelines/conversations/
     */
    remove(id: string): Promise<void>;
    /**
     * Mark as read
     * @param id ID of the conversation in the database
     * @return Conversation
     * @see https://docs.joinmastodon.org/methods/timelines/conversations/
     */
    read(id: string): Promise<Conversation>;
}

declare class CustomEmojiRepository implements Repository<CustomEmoji> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Returns custom emojis that are available on the server.
     * @return Array of Emoji
     * @see https://docs.joinmastodon.org/methods/instance/custom_emojis/
     */
    list(): Paginator<CustomEmoji[]>;
}

type DirectoryOrderType = 'active' | 'new';
interface ListDirectoryParams {
    /** How many accounts to load. Default 40. */
    readonly limit?: number | null;
    /** How many accounts to skip before returning results. Default 0. */
    readonly offset?: number | null;
    /** `active` to sort by most recently posted statuses (default) or `new` to sort by most recently created profiles. */
    readonly order?: DirectoryOrderType | null;
    /** Only return local accounts. */
    readonly local?: boolean | null;
}
declare class DirectoryRepository implements Repository<Account$1, never, never, never, ListDirectoryParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * List accounts visible in the directory.
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/instance/directory/
     */
    list(params?: ListDirectoryParams): Paginator<Account$1[], ListDirectoryParams>;
}

declare class DomainBlockRepository$1 implements Repository<string, never, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View domains the user has blocked.
     * @param params Parameters
     * @return Array of strings
     * @see https://docs.joinmastodon.org/methods/accounts/domain_blocks/
     */
    list(params?: DefaultPaginationParams): Paginator<string[], DefaultPaginationParams>;
    /**
     * Block a domain to:
     * - hide all public posts from it
     * - hide all notifications from it
     * - remove all followers from it
     * - prevent following new users from it (but does not remove existing follows)
     * @param domain Domain to block.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/domain_blocks/
     */
    block(domain: string): Promise<void>;
    /**
     * Remove a domain block, if it exists in the user's array of blocked domains.
     * @param domain Domain to unblock
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/domain_blocks/
     */
    unblock(domain: string): Promise<void>;
}

declare class EndorsementRepository implements Repository<Account$1, never, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Accounts that the user is currently featuring on their profile.
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/endorsements/
     */
    list(params?: DefaultPaginationParams): Paginator<Account$1[], DefaultPaginationParams>;
}

declare class FavouriteRepository implements Repository<Status, never, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Statuses the user has favourited.
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/accounts/favourites/
     */
    list(params?: DefaultPaginationParams): Paginator<Status[], DefaultPaginationParams>;
}

interface CreateFeaturedTagParams {
    /** The hashtag to be featured. */
    readonly name: string;
}
declare class FeaturedTagRepository implements Repository<FeaturedTag> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View your featured tags
     * @return Array of FeaturedTag
     * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
     * @done
     */
    list(): Paginator<FeaturedTag[]>;
    /**
     * Feature a tag
     * @param params Parameters
     * @return FeaturedTag
     * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
     */
    create(params: CreateFeaturedTagParams): Promise<FeaturedTag>;
    /**
     * Shows your 10 most-used tags, with usage history for the past week.
     * @return Array of Tag with History
     * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
     */
    listSuggestions(): Paginator<Tag[]>;
    /**
     * Un-feature a tag
     * @param id The id of the FeaturedTag to be un-featured
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
     */
    remove(id: string): Promise<void>;
}

interface CreateFilterParams$1 {
    /** Text to be filtered */
    readonly phrase: string;
    /**
     * Array of enumerable strings `home`, `notifications`, `public`, `thread`.
     * At least one context must be specified.
     */
    readonly context: FilterContext$1[] | null;
    /** Should the server irreversibly drop matching entities from home and notifications? */
    readonly irreversible?: boolean | null;
    /** Consider word boundaries? */
    readonly wholeWord?: boolean | null;
    /** ISO 8601 Date-time for when the filter expires. Otherwise, null for a filter that doesn't expire. */
    readonly expiresIn?: number | null;
}
type UpdateFilterParams$1 = CreateFilterParams$1;
declare class FilterRepository$1 implements Repository<Filter$1, CreateFilterParams$1, UpdateFilterParams$1> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View all filters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    list(): Paginator<Filter$1[]>;
    /**
     * View a single filter
     * @param id ID of the filter
     * @return Returns Filter
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    fetch(id: string): Promise<Filter$1>;
    /**
     * Create a filter
     * @param params Parameters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    create(params?: CreateFilterParams$1): Promise<Filter$1>;
    /**
     * Update a filter
     * @param id ID of the filter in the database
     * @param params Parameters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    update(id: string, params?: UpdateFilterParams$1): Promise<Filter$1>;
    /**
     * Remove a filter
     * @param id ID of the filter in the database
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    remove(id: string): Promise<void>;
}

declare class FollowRequestRepository implements Repository<Account$1, never, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Pending Follows
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/follow_requests/
     */
    list(params?: DefaultPaginationParams): Paginator<Account$1[], DefaultPaginationParams>;
    /**
     * Accept Follow
     * @param id ID of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/follow_requests/
     */
    authorize(id: string): Promise<Relationship>;
    /**
     * Reject Follow
     * @param id ID of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/follow_requests/
     */
    reject(id: string): Promise<Relationship>;
}

declare class InstanceRepository$1 implements Repository<Instance$1> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Information about the server.
     * @return Instance
     * @see https://docs.joinmastodon.org/methods/instance/
     */
    fetch(): Promise<Instance$1>;
    /**
     * Domains that this instance is aware of.
     * @return Array of Activity
     * @see https://docs.joinmastodon.org/methods/instance/
     */
    listPeers(): Paginator<string[]>;
    /**
     * Instance activity over the last 3 months, binned weekly.
     * @return Array of Activity
     * @see https://docs.joinmastodon.org/methods/instance/
     */
    listActivities(): Paginator<Activity[]>;
}

interface CreateListParams {
    /** The title of the list to be created. */
    readonly title: string;
}
type UpdateListParams = CreateListParams;
interface AddListAccountsParams {
    /** Array of account IDs */
    readonly accountIds: string[];
}
type RemoveListAccountsParams = AddListAccountsParams;
declare class ListRepository implements Repository<List, CreateListParams, UpdateListParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Fetch the list with the given ID. Used for verifying the title of a list.
     * @param id ID of the list in the database
     * @return List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    fetch(id: string): Promise<List>;
    /**
     * Fetch all lists that the user owns.
     * @return Array of List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    list(): Paginator<List[]>;
    /**
     * Create a new list.
     * @param params Parameters
     * @return List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    create(params: CreateListParams): Promise<List>;
    /**
     * Change the title of a list.
     * @param id ID of the list in the database
     * @param params Parameters
     * @return List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    update(id: string, params: UpdateListParams): Promise<List>;
    /**
     * Delete a list
     * @param id ID of the list in the database
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    remove(id: string): Promise<void>;
    /**
     * View accounts in list
     * @param id ID of the list in the database
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/timelines/lists#accounts
     */
    listAccounts(id: string, params?: DefaultPaginationParams): Paginator<Account$1[], DefaultPaginationParams>;
    /**
     * Add accounts to the given list. Note that the user must be following these accounts.
     * @param id ID of the list in the database
     * @param params Parameters
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/timelines/lists#accounts-add
     */
    addAccount(id: string, params: AddListAccountsParams): Promise<void>;
    /**
     * Remove accounts from the given list.
     * @param id ID of the list in the database
     * @param params Parameters
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/timelines/lists#accounts-remove
     */
    removeAccount(id: string, params: RemoveListAccountsParams): Promise<void>;
}

interface FetchMarkersParams {
    /**
     * Array of markers to fetch.
     * String enum anyOf `home`, `notifications`.
     * If not provided, an empty object will be returned.
     */
    readonly timeline?: readonly MarkerTimeline[];
}
type CreateMarkersParams = {
    /** ID of the last status read in the timeline. */
    readonly [key in MarkerTimeline]?: Pick<MarkerItem, 'lastReadId'>;
};
declare class MarkerRepository implements Repository<Marker, CreateMarkersParams, never, FetchMarkersParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Get saved timeline position
     * @param params Parameters
     * @return Markers
     * @see https://docs.joinmastodon.org/methods/timelines/markers/
     */
    fetch(params?: FetchMarkersParams): Promise<Marker>;
    /**
     * Save position in timeline
     * @param params Parameters
     * @return Markers
     * @see https://github.com/tootsuite/mastodon/pull/11762
     */
    create(params: CreateMarkersParams): Promise<Marker>;
}

interface CreateMediaAttachmentParams$1 {
    /** The file to be attached, using multipart form data. */
    readonly file: unknown;
    /** A plain-text description of the media, for accessibility purposes. */
    readonly description?: string | null;
    /** Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0 */
    readonly focus?: string | null;
    /** Custom thumbnail */
    readonly thumbnail?: unknown | null;
}
type UpdateMediaAttachmentParams = Partial<CreateMediaAttachmentParams$1>;
declare class MediaAttachmentRepository$1 implements Repository<MediaAttachment, CreateMediaAttachmentParams$1, UpdateMediaAttachmentParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Creates an attachment to be used with a new status.
     * @param params Parameters
     * @return Attachment
     * @see https://docs.joinmastodon.org/methods/statuses/media/
     */
    create(params: CreateMediaAttachmentParams$1): Promise<MediaAttachment>;
    /**
     * Fetches an attachment to be used with a new status.
     * @param id ID of the attachment
     * @see https://github.com/tootsuite/mastodon/pull/13210
     */
    fetch(id: string): Promise<MediaAttachment>;
    /**
     * Update an Attachment, before it is attached to a status and posted.
     * @param id The id of the Attachment entity to be updated
     * @param params Parameters
     * @return Attachment
     * @see https://docs.joinmastodon.org/methods/statuses/media/
     */
    update(id: string, params: UpdateMediaAttachmentParams): Promise<MediaAttachment>;
}

declare class MuteRepository implements Repository<Account$1, never, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Accounts the user has muted.
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/mutes/
     */
    list(params?: DefaultPaginationParams): Paginator<Account$1[], DefaultPaginationParams>;
}

interface ListNotificationsParams extends DefaultPaginationParams {
    /** Instead of specifying every known type to exclude, you can specify only the types you want. */
    readonly types?: NotificationType[] | null;
    /** ID of the account */
    readonly accountId?: string | null;
    /** Array of notifications to exclude (Allowed values: "follow", "favourite", "reblog", "mention") */
    readonly excludeTypes?: NotificationType[] | null;
}
declare class NotificationRepository implements Repository<Notification, never, never, never, ListNotificationsParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Notifications concerning the user.
     * This API returns Link headers containing links to the next/previous page.
     * However, the links can also be constructed dynamically using query params and `id` values.
     * @param params Query parameter
     * @return Array of Notification
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    list(params?: ListNotificationsParams): Paginator<Notification[], ListNotificationsParams>;
    /**
     * View information about a notification with a given ID.
     * @param id ID of the notification in the database.
     * @return Notification
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    fetch(id: string): Promise<Notification>;
    /**
     * Clear all notifications from the server.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    clear(): Promise<void>;
    /**
     * Clear a single notification from the server.
     * @param id ID of the notification to be cleared
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    dismiss(id: string): Promise<void>;
}

interface VotePollParams {
    /** Array of own votes containing index for each option (starting from 0) */
    readonly choices: number[];
}
declare class PollRepository implements Repository<Poll> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View a poll
     * @param id ID of the poll in the database
     * @return Poll
     * @see https://docs.joinmastodon.org/methods/statuses/polls#get
     */
    fetch(id: string): Promise<Poll>;
    /**
     * Vote on a poll
     * @param id ID of the poll in the database
     * @param params Parameters
     * @return Poll
     * @see https://docs.joinmastodon.org/methods/statuses/polls#vote
     */
    vote(id: string, params: VotePollParams): Promise<Poll>;
}

declare class PreferenceRepository implements Repository<Preference> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Preferences defined by the user in their account settings.
     * @return Preferences by key and value
     * @see https://docs.joinmastodon.org/methods/accounts/preferences/
     */
    fetch(): Promise<Preference>;
}

interface CreateWebPushSubscriptionParams {
    readonly subscription: {
        /** Endpoint URL that is called when a notification event occurs. */
        readonly endpoint: string;
        readonly keys: {
            /** User agent public key. Base64 encoded string of public key of ECDH key using `prime256v1` curve. */
            readonly p256dh: string;
            /** Auth secret. Base64 encoded string of 16 bytes of random data. */
            readonly auth: string;
        };
    };
    readonly data?: {
        readonly alerts?: Partial<WebPushSubscriptionAlerts> | null;
    } | null;
    readonly policy: WebPushSubscriptionPolicy;
}
type UpdateWebPushSubscriptionParams = Pick<CreateWebPushSubscriptionParams, 'data'>;
declare class WebPushSubscriptionRepository implements Repository<WebPushSubscription, CreateWebPushSubscriptionParams, UpdateWebPushSubscriptionParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Add a Web Push API subscription to receive notifications.
     * Each access token can have one push subscription.
     * If you create a new subscription, the old subscription is deleted.
     * @param params Parameters
     * @return Returns Push Subscription
     * @see https://docs.joinmastodon.org/methods/notifications/push/
     */
    create(params: CreateWebPushSubscriptionParams): Promise<WebPushSubscription>;
    /**
     * View the PushSubscription currently associated with this access token.
     * @return PushSubscription
     * @see https://docs.joinmastodon.org/methods/notifications/push/
     */
    fetch(): Promise<WebPushSubscription>;
    /**
     * Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead.
     * @param params Parameters
     * @return PushSubscription
     * @see https://docs.joinmastodon.org/methods/notifications/push/
     */
    update(params: UpdateWebPushSubscriptionParams): Promise<WebPushSubscription>;
    /**
     * Removes the current Web Push API subscription.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/notifications/push/
     */
    remove(): Promise<void>;
}

type ReportCategory = 'spam' | 'violation' | 'other';
interface ReportAccountParams {
    /** ID of the account to report */
    readonly accountId: string;
    /** Array of Statuses to attach to the report, for context */
    readonly statusIds?: string[] | null;
    /** Reason for the report (default max 1000 characters) */
    readonly comment?: string | null;
    /** If the account is remote, should the report be forwarded to the remote admin? */
    readonly forward?: boolean | null;
    /** category can be one of: spam, violation, other (default) */
    readonly category?: ReportCategory | null;
    /** must reference rules returned in GET /api/v1/instance */
    readonly ruleIds?: string[] | null;
}
declare class ReportRepository$1 {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * File a report
     * @param params Parameters
     * @return Report
     * @see https://docs.joinmastodon.org/methods/accounts/reports/
     */
    create(params: ReportAccountParams): Promise<void>;
}

interface UpdateScheduledStatusParams {
    /** ISO 8601 Date-time at which the status will be published. Must be at least 5 minutes into the future. */
    readonly scheduledAt: string;
}
declare class ScheduledStatusRepository implements Repository<ScheduledStatus, never, UpdateScheduledStatusParams, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View scheduled statuses
     * @param params Parameters
     * @return Array of ScheduledStatus
     * @see https://docs.joinmastodon.org/methods/statuses/scheduled_statuses/
     */
    list(params?: DefaultPaginationParams): Paginator<ScheduledStatus[], DefaultPaginationParams>;
    /**
     * View a single scheduled status
     * @param id ID of the scheduled status in the database.
     * @return ScheduledStatus
     * @see https://docs.joinmastodon.org/methods/statuses/scheduled_statuses/
     */
    fetch(id: string): Promise<ScheduledStatus>;
    /**
     * Update Scheduled status
     * @param id ID of the Status to be scheduled
     * @param params Parameters
     * @return ScheduledStatus
     * @see https://docs.joinmastodon.org/api/rest/scheduled-statuses/#put-api-v1-scheduled-statuses-id
     */
    update(id: string, params: UpdateScheduledStatusParams): Promise<ScheduledStatus>;
    /**
     * Cancel a scheduled status
     * @param id ID of the scheduled status in the database.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/statuses/scheduled_statuses/
     */
    remove(id: string): Promise<void>;
}

interface CreateStatusParamsBase {
    /** ID of the status being replied to, if status is a reply */
    readonly inReplyToId?: string | null;
    /** Mark status and attached media as sensitive? */
    readonly sensitive?: boolean | null;
    /** Text to be shown as a warning or subject before the actual content. Statuses are generally collapsed behind this field. */
    readonly spoilerText?: string | null;
    /** Visibility of the posted status. Enumerable oneOf public, unlisted, private, direct. */
    readonly visibility?: StatusVisibility | null;
    /** ISO 639 language code for this status. */
    readonly language?: string | null;
}
interface CreateStatusExtraParams {
    readonly idempotencyKey?: string | null;
}
interface CreateStatusPollParam {
    /** Array of possible answers. If provided, `media_ids` cannot be used, and `poll[expires_in]` must be provided. */
    readonly options: string[];
    /** Duration the poll should be open, in seconds. If provided, media_ids cannot be used, and poll[options] must be provided. */
    readonly expiresIn: number;
    /** Allow multiple choices? */
    readonly multiple?: boolean | null;
    /** Hide vote counts until the poll ends? */
    readonly hideTotals?: boolean | null;
}
interface CreateStatusParamsWithStatus extends CreateStatusParamsBase {
    /** Text content of the status. If `media_ids` is provided, this becomes optional. Attaching a `poll` is optional while `status` is provided. */
    readonly status: string;
    /** Array of Attachment ids to be attached as media. If provided, `status` becomes optional, and `poll` cannot be used. */
    readonly mediaIds?: never;
    readonly poll?: CreateStatusPollParam | null;
}
interface CreateStatusParamsWithMediaIds extends CreateStatusParamsBase {
    /** Array of Attachment ids to be attached as media. If provided, `status` becomes optional, and `poll` cannot be used. */
    readonly mediaIds: readonly string[];
    /** Text content of the status. If `media_ids` is provided, this becomes optional. Attaching a `poll` is optional while `status` is provided. */
    readonly status?: string | null;
    readonly poll?: never;
}
type CreateStatusParams = CreateStatusParamsWithStatus | CreateStatusParamsWithMediaIds;
type CreateScheduledStatusParams = CreateStatusParams & {
    /** ISO 8601 Date-time at which to schedule a status. Providing this parameter will cause ScheduledStatus to be returned instead of Status. Must be at least 5 minutes in the future. */
    readonly scheduledAt?: string | null;
};
type UpdateStatusMediaAttribute = {
    /** The ID of the media attachment to be modified */
    readonly id: string;
    /** A plain-text description of the media, for accessibility purposes. */
    readonly description?: string | null;
    /** Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0 */
    readonly focus?: string | null;
    /** Custom thumbnail */
    readonly thumbnail?: unknown | null;
};
type UpdateStatusParams = CreateStatusParams & {
    /** https://github.com/mastodon/mastodon/pull/20878 */
    readonly mediaAttributes?: readonly UpdateStatusMediaAttribute[];
};
interface ReblogStatusParams {
    /** any visibility except limited or direct (i.e. public, unlisted, private). Defaults to public. Currently unused in UI. */
    readonly visibility: StatusVisibility;
}
interface TranslateStatusParams {
    /** String (ISO 639 language code). The status content will be translated into this language. Defaults to the user’s current locale. */
    readonly lang?: string;
}
declare class StatusRepository implements Repository<Status> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View information about a status.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    fetch(id: string): Promise<Status>;
    /**
     * Post a new status.
     * @param params Parameters
     * @param idempotencyKey Prevent duplicate submissions of the same status. Idempotency keys are stored for up to 1 hour, and can be any arbitrary string. Consider using a hash or UUID generated client-side.
     * @return Status. When scheduled_at is present, ScheduledStatus is returned instead.
     * @see https://docs.joinmastodon.org/api/rest/statuses/#post-api-v1-statuses
     */
    create(params: CreateStatusParams, extra?: CreateStatusExtraParams): Promise<Status>;
    create(params: CreateScheduledStatusParams, extra?: CreateStatusExtraParams): Promise<ScheduledStatus>;
    /**
     * Update a status
     * @param params Parameters
     * @return Status. When scheduled_at is present, ScheduledStatus is returned instead.
     * @see https://docs.joinmastodon.org/api/rest/statuses/#post-api-v1-statuses
     */
    update(id: string, params: UpdateStatusParams): Promise<Status>;
    /**
     * Delete one of your own statuses.
     * @param id Local ID of a status in the database. Must be owned by authenticated account.
     * @return Status with source text and `media_attachments` or `poll`
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    remove(id: string): Promise<Status>;
    /**
     * View statuses above and below this status in the thread.
     * @param id Local ID of a status in the database.
     * @return Context
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    fetchContext(id: string): Promise<Context>;
    /**
     * Preview card
     * @deprecated Use `card` attribute of status instead
     * @param id ID of the status in the database
     * @return Card
     * @see https://docs.joinmastodon.org/api/rest/statuses/#get-api-v1-statuses-id-card
     */
    fetchCard(id: string): Promise<PreviewCard>;
    /**
     * Add a status to your favourites list.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    favourite(id: string): Promise<Status>;
    /**
     * Remove a status from your favourites list.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    unfavourite(id: string): Promise<Status>;
    /**
     * Do not receive notifications for the thread that this status is part of. Must be a thread in which you are a participant.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    mute(id: string): Promise<Status>;
    /**
     * Start receiving notifications again for the thread that this status is part of.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    unmute(id: string): Promise<Status>;
    /**
     * View who boosted a given status.
     * @param id Local ID of a status in the database.
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    listRebloggedBy(id: string): Paginator<Account$1[]>;
    /**
     * View who favourited a given status.
     * @param id Local ID of a status in the database.
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    listFavouritedBy(id: string): Paginator<Account$1[]>;
    /**
     * Re-share a status.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/api/rest/statuses/#post-api-v1-statuses-id-reblog
     */
    reblog(id: string, params?: ReblogStatusParams): Promise<Status>;
    /**
     * Undo a re-share of a status.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    unreblog(id: string): Promise<Status>;
    /**
     * Feature one of your own public statuses at the top of your profile.
     * @param id Local ID of a status in the database. The status should be public and authored by the authorized account.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    pin(id: string): Promise<Status>;
    /**
     * Un-feature a status from the top of your profile.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    unpin(id: string): Promise<Status>;
    /**
     * Privately bookmark a status.
     * @param id ID of the status in the database
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    bookmark(id: string): Promise<Status>;
    /**
     * Remove a status from your private bookmarks.
     * @param id ID of the status in the database
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    unbookmark(id: string): Promise<Status>;
    /**
     * Get all known versions of a status, including the initial and current states.
     * @param id The local id of the status in the database
     * @returns StatusEdit
     * @see https://docs.joinmastodon.org/methods/statuses/#history
     */
    listHistory(id: string): Paginator<StatusEdit[]>;
    /**
     * Obtain the source properties for a status so that it can be edited.
     * @param id The local ID of the Status in the database
     * @returns StatusSource
     * @see https://docs.joinmastodon.org/methods/statuses/#source
     */
    fetchSource(id: string): Promise<StatusSource>;
    /**
     * Translate the status content into some language.
     * @param id String. The ID of the Status in the database.
     * @param params Form data parameters
     * @returns Translation
     */
    translate(id: string, params: TranslateStatusParams): Promise<Translation>;
}

interface ListSuggestionParams {
    /** Integer. Maximum number of results to return. Defaults to 40. */
    readonly limit?: number | null;
}
declare class SuggestionRepository$1 implements Repository<Account$1, never, never, never, ListSuggestionParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Accounts the user has had past positive interactions with, but is not yet following.
     * @param params
     * @returns
     * @see https://docs.joinmastodon.org/methods/suggestions/#v1
     */
    list(params?: ListSuggestionParams): Paginator<Account$1[], ListSuggestionParams>;
    /**
     * Remove an account from follow suggestions.
     * @param id id of the account in the database to be removed from suggestions
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/suggestions/
     */
    remove(id: string): Promise<void>;
}

interface ListTimelineParams extends DefaultPaginationParams {
    /** Show only local statuses? Defaults to false. */
    readonly local?: boolean | null;
    /** Show only statuses with media attached? Defaults to false. */
    readonly onlyMedia?: boolean | null;
    /** Remote only */
    readonly remote?: boolean | null;
}
declare class TimelineRepository {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View statuses from followed users.
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/timelines/
     */
    listHome(params?: ListTimelineParams): Paginator<Status[], ListTimelineParams>;
    /**
     * Public timeline
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/timelines/
     */
    listPublic(params?: ListTimelineParams): Paginator<Status[], ListTimelineParams>;
    /**
     * View public statuses containing the given hashtag.
     * @param hashtag Content of a #hashtag, not including # symbol.
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/timelines/
     */
    listHashtag(hashtag: string, params?: ListTimelineParams): Paginator<Status[], ListTimelineParams>;
    /**
     * View statuses in the given list timeline.
     * @param id Local ID of the list in the database.
     * @param params Query parameter
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/timelines/
     */
    listList(id: string, params?: ListTimelineParams): Paginator<Status[], ListTimelineParams>;
    /**
     * View statuses with a “direct” privacy, from your account or in your notifications.
     * @deprecated Use conversations API instead
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/timelines/
     */
    listDirect(params?: ListTimelineParams): Paginator<Status[], ListTimelineParams>;
}

interface ListTrendsParams {
    /** Maximum number of results to return. Defaults to 10. */
    readonly limit: number;
}
declare class TrendRepository$1 {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View trending statuses
     * @returns Array of Status
     * @see https://docs.joinmastodon.org/methods/trends/#statuses
     */
    listStatuses(params?: DefaultPaginationParams): Paginator<Status[], DefaultPaginationParams>;
    /**
     * Links that have been shared more than others.
     * @see https://docs.joinmastodon.org/methods/trends/#links
     */
    listLinks(params?: DefaultPaginationParams): Paginator<TrendLink[], DefaultPaginationParams>;
    /**
     * Tags that are being used more frequently within the past week.
     * @param params Parameters
     * @return Array of Tag with History
     * @see https://docs.joinmastodon.org/methods/trends/#tags
     */
    listTags(params?: ListTrendsParams): Paginator<Tag[], ListTrendsParams>;
}

interface CreateConfirmationParams {
    /** If provided, updates the unconfirmed user’s email before resending the confirmation email. */
    readonly email?: string;
}
declare class EmailRepository {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Resend confirmation email
     * @param params Form data parameters
     * @returns Empty object
     * @see https://docs.joinmastodon.org/methods/emails/#confirmation
     */
    createConfirmation(params?: CreateConfirmationParams): Promise<void>;
}

declare class TagRepository implements Repository<Tag> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Show a hashtag and its associated information
     * @param id The name of the hashtag
     * @return Tag
     */
    fetch(id: string): Promise<Tag>;
    /**
     * Follow a hashtag. Posts containing a followed hashtag will be inserted into your home timeline.
     * @param id The name of the hashtag
     * @return Tag
     */
    follow(id: string): Promise<Tag>;
    /**
     * Unfollow a hashtag. Posts containing a followed hashtag will no longer be inserted into your home timeline.
     * @param id The name of the hashtag
     * @return Tag
     */
    unfollow(id: string): Promise<Tag>;
}

declare class FollowedTagRepository implements Repository<Tag, never, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    list(params?: DefaultPaginationParams): Paginator<Tag[], DefaultPaginationParams>;
}

interface ListAccountsParams extends DefaultPaginationParams {
    /** Filter for local accounts? */
    readonly local?: boolean | null;
    /** Filter for remote accounts? */
    readonly remote?: boolean | null;
    /** Filter by the given domain */
    readonly byDomain?: string | null;
    /** Filter for currently active accounts? */
    readonly active?: boolean | null;
    /** Filter for currently pending accounts? */
    readonly pending?: boolean | null;
    /** Filter for currently disabled accounts? */
    readonly disabled?: boolean | null;
    /** Filter for currently silenced accounts? */
    readonly silenced?: boolean | null;
    /** Filter for currently suspended accounts? */
    readonly suspended?: boolean | null;
    /** Boolean. Filter for accounts force-marked as sensitive? */
    readonly sensitized?: boolean | null;
    /** Username to search for */
    readonly username?: string | null;
    /** Display name to search for */
    readonly displayName?: string | null;
    /** Lookup a user with this email */
    readonly email?: string | null;
    /** Lookup users by this IP address */
    readonly ip?: string | null;
    /** Filter for staff accounts? */
    readonly staff?: boolean | null;
}
type AccountActionType = 'none' | 'disable' | 'silence' | 'sensitive' | 'suspend';
interface CreateActionParams {
    /** Type of action to be taken. Enumerable oneOf: `none` `disable` `silence` `suspend` */
    readonly type?: AccountActionType;
    /** ID of an associated report that caused this action to be taken */
    readonly reportId?: string;
    /** ID of a preset warning */
    readonly warningPresetId?: string | null;
    /** Additional text for clarification of why this action was taken */
    readonly text?: string | null;
    /** Whether an email should be sent to the user with the above information. */
    readonly sendEmailNotification?: boolean | null;
}
declare class AccountRepository implements Repository<Account, never, never, never, ListAccountsParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View accounts matching certain criteria for filtering, up to 100 at a time.
     * Pagination may be done with the HTTP Link header in the response.
     * @param params Parameters
     * @return Array of AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params?: ListAccountsParams): Paginator<Account[], ListAccountsParams>;
    /**
     * View admin-level information about the given account.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    fetch(id: string): Promise<Account>;
    /**
     * Perform an action against an account and log this action in the moderation history.
     * @param id g ID of the account
     * @param params Params
     * @return Account
     * @see https://docs.joinmastodon.org/methods/admin/accounts/#action
     */
    createAction(id: string, params: CreateActionParams): Promise<void>;
    /**
     * Approve the given local account if it is currently pending approval.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    approve(id: string): Promise<Account>;
    /**
     * Reject the given local account if it is currently pending approval.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    reject(id: string): Promise<Account>;
    /**
     * Re-enable a local account whose login is currently disabled.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    enable(id: string): Promise<Account>;
    /**
     * Unsilence a currently silenced account.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    unsilence(id: string): Promise<Account>;
    /**
     * Unsuspend a currently suspended account.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    unsuspend(id: string): Promise<Account>;
    /**
     * Unmark an account as sensitive
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/accounts/#unsensitive
     */
    unsensitive(id: string): Promise<Account>;
}

interface TestCanonicalEmailBlockParams {
    /** The email to canonicalize and hash */
    readonly email: string;
}
interface CreateCanonicalEmailBlockParamsWithEmail {
    /** The email to canonicalize, hash, and block. If this parameter is provided, canonical_email_hash will be ignored. */
    readonly email: string;
}
interface CreateCanonicalEmailBlockParamsWithCanonicalEmailHash {
    /** The hash to test against. If email is not provided, this parameter is required. */
    readonly canonicalEmailHash: string;
}
type CreateCanonicalEmailBlockParams = CreateCanonicalEmailBlockParamsWithEmail | CreateCanonicalEmailBlockParamsWithCanonicalEmailHash;
declare class CanonicalEmailBlockRepository implements Repository<CanonicalEmailBlock, CreateCanonicalEmailBlockParams, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * List all canonical email blocks.
     * @param params Parameters
     * @return Array of CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks/
     */
    list(params?: DefaultPaginationParams): Paginator<CanonicalEmailBlock[], DefaultPaginationParams>;
    /**
     * Show a single canonical email block
     * @param id id of the canonical email
     * @return CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks
     */
    fetch(id: string): Promise<CanonicalEmailBlock>;
    /**
     * Canonicalize and hash an email address.
     * @param params Parameters
     * @return Array of CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks/#test
     */
    test(params: TestCanonicalEmailBlockParams): Promise<CanonicalEmailBlock[]>;
    /**
     * Block a canonical email.
     * @param params Parameters
     * @return CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks
     */
    create(params: CreateCanonicalEmailBlockParams): Promise<CanonicalEmailBlock>;
    /**
     * Lift a block a canonical email.
     * @param id id of canonical email
     * @return null
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks
     */
    remove(id: string): Promise<void>;
}

interface FetchDimensionParams {
    /**
     * Array of String. Request specific dimensions by their keystring. Supported dimensions include:
     *
     * - `languages` = Most-used languages on this server
     *
     * - `sources` = Most-used client apps on this server
     *
     * - `servers` = Remote servers with the most statuses
     *
     * - `space_usage` = How much space is used by your software stack
     *
     * - `software_versions` = The version numbers for your software stack
     *
     * - `tag_servers` = Most-common servers for statuses including a trending tag
     *
     * - `tag_languages` = Most-used languages for statuses including a trending tag
     *
     * - `instance_accounts` = Most-followed accounts from a remote server
     *
     * - `instance_languages` = Most-used languages from a remote server
     */
    readonly keys: readonly DimensionKey[];
    /** String (ISO 8601 Datetime). The start date for the time period. If a time is provided, it will be ignored. */
    readonly startAt?: string | null;
    /** String (ISO 8601 Datetime). The end date for the time period. If a time is provided, it will be ignored. */
    readonly endAt?: string | null;
    /** Integer. The maximum number of results to return for sources, servers, languages, tag or instance dimensions. */
    readonly limit?: string | null;
    readonly tagServers?: {
        /** String. When `tag_servers` is one of the requested keys, you must provide a trending tag ID to obtain information about which servers are posting the tag. */
        readonly id?: string | null;
    } | null;
    readonly tagLanguages?: {
        /** String. When `tag_languages` is one of the requested keys, you must provide a trending tag ID to obtain information about which languages are posting the tag. */
        readonly id?: string | null;
    } | null;
    readonly instanceAccounts?: {
        /** String. When `instance_accounts` is one of the requested keys, you must provide a domain to obtain information about popular accounts from that server. */
        readonly domain?: string | null;
    } | null;
    readonly instanceLanguages?: {
        /** String. When `instance_accounts` is one of the requested keys, you must provide a domain to obtain information about popular languages from that server. */
        readonly domain?: string | null;
    } | null;
}
declare class DimensionRepository {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Obtain information about popularity of certain accounts, servers, languages, etc.
     * @see https://docs.joinmastodon.org/methods/admin/dimensions/#get
     */
    fetch(params: FetchDimensionParams): Promise<Dimension[]>;
}

interface CreateDomainAllowParams {
    readonly domain: string;
}
declare class DomainAllowRepository implements Repository<DomainAllow, CreateDomainAllowParams, never, never, DefaultPaginationParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Show information about all allowed domains
     * @param params Parameters
     * @return Array of DomainAllow
     * @see https://docs.joinmastodon.org/methods/admin/domain_allows/#get
     */
    list(params?: DefaultPaginationParams): Paginator<DomainAllow[], DefaultPaginationParams>;
    /**
     * Show information about a single allowed domain
     * @param id id of the domain
     * @return DomainAllow
     * @see https://docs.joinmastodon.org/methods/admin/domain_allows/#get-one
     */
    fetch(id: string): Promise<DomainAllow>;
    /**
     * Add a domain to the list of domains allowed to federate,
     * to be used when the instance is in allow-list federation mode.
     * @param params parameters
     * @return DomainAllow
     * @see https://docs.joinmastodon.org/methods/admin/domain_allows/#get-one
     */
    create(params: CreateDomainAllowParams): Promise<DomainAllow>;
    /**
     * Delete a domain from the allowed domains list.
     * @param id id of domain
     * @return DomainAllow
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    remove(id: string): Promise<DomainAllow>;
}

interface CreateDomainBlockParams {
    /** The domain to block federation required*/
    readonly domain: string;
    /** Whether to apply a silence, suspend, or noop to the domain?*/
    readonly severity?: DomainBlockSeverity;
    /** Whether media attachments should be rejected*/
    readonly rejectMedia?: boolean;
    /** Whether reports from this domain should be rejected*/
    readonly rejectReports?: boolean;
    /**  A private note about this domain block, visible only to admins*/
    readonly privateComment?: string | null;
    /** A public note about this domain block, optionally shown on the about page*/
    readonly publicComment?: string | null;
    /** Whether to partially censor the domain when shown in public*/
    readonly obfuscate?: boolean;
}
type ListDomainBlocksParams = {
    readonly limit?: number;
};
type UpdateDomainBlockParams = Omit<CreateDomainBlockParams, 'domain'>;
declare class DomainBlockRepository implements Repository<DomainBlock, CreateDomainBlockParams, UpdateDomainBlockParams, never, ListDomainBlocksParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     *
     * @param params Parameters
     * @return Array of DomainBlocks
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params?: ListDomainBlocksParams): Paginator<DomainBlock[], ListDomainBlocksParams>;
    /**
     * Show information about a single blocked domain.
     * @param id ID of the account
     * @return DomainBlocks
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    fetch(id: string): Promise<DomainBlock>;
    /**
     * Add a domain to the list of domains blocked from federating.
     * @param params Parameters
     * @return DomainBlocks
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    create(params: CreateDomainBlockParams): Promise<DomainBlock>;
    /**
     * Change parameters for an existing domain block.
     * @param id id of domain
     * @param params Parameters
     * @return DomainBlocks
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    update(id: string, params?: UpdateDomainBlockParams): Promise<DomainBlock>;
    /**
     * Lift a block against a domain.
     * @param id id of domain
     * @return DomainBlocks
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    remove(id: string): Promise<void>;
}

type ListEmailDomainBlocksParams = {
    /** Integer. Maximum number of results to return. Defaults to 100. */
    readonly limit?: number | null;
};
interface CreateEmailDomainBlockParams {
    /** The domain to block federation with. */
    readonly domain: string;
}
declare class EmailDomainBlockRepository implements Repository<EmailDomainBlock, CreateEmailDomainBlockParams, never, never, ListEmailDomainBlocksParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Show information about all email domains blocked from signing up.
     * @param params Parameters
     * @return Array of EmailDomainBlock
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params?: ListEmailDomainBlocksParams): Paginator<EmailDomainBlock[], ListEmailDomainBlocksParams>;
    /**
     * Show information about a single email domain that is blocked from sign-ups.
     * @param id id of the DomainBlock
     * @return Array of EmailDomainBlock
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    fetch(id: string): Promise<EmailDomainBlock>;
    /**
     * Add a domain to the list of email domains blocked from sign-ups.
     * @param params Parameters
     * @return Array of EmailDomainBlock
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    create(params: CreateEmailDomainBlockParams): Promise<EmailDomainBlock>;
    /**
     * Lift a block against an email domain.
     * @param id id of domain
     * @return null
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    remove(id: string): Promise<void>;
}

type ListIpBlocksParams = {
    /** Integer. Maximum number of results to return. Defaults to 100. */
    readonly limit?: number | null;
};
interface CreateIpBlockParams {
    /** The IP address and prefix to block. */
    readonly ip?: string;
    /** The policy to apply to this IP range. */
    readonly severity: IpBlockSeverity;
    /** The reason for this IP block. */
    readonly comment?: string;
    /** The number of seconds in which this IP block will expire. */
    readonly expiresIn?: number | null;
}
interface UpdateIpBlockParams {
    /** The IP address and prefix to block. */
    readonly ip?: string;
    /** The policy to apply to this IP range. */
    readonly severity?: IpBlockSeverity;
    /** The reason for this IP block. */
    readonly comment?: string;
    /** The number of seconds in which this IP block will expire. */
    readonly expiresIn?: number | null;
}
declare class IpBlockRepository implements Repository<IpBlock, CreateIpBlockParams, UpdateIpBlockParams, never, ListIpBlocksParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Show information about all blocked IP ranges.
     * @param params Parameters
     * @return Array of Ip Block
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params?: ListIpBlocksParams): Paginator<IpBlock[], ListIpBlocksParams>;
    /**
     * Show information about all blocked IP ranges.
     * @param id id of the Ip blocked
     * @return object of Ip Block
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    fetch(id: string): Promise<IpBlock>;
    /**
     * Add an IP address range to the list of IP blocks.
     * @param params Parameters
     * @return object of Ip Block
     * @see https://docs.joinmastodon.org/methods/admin/ip_blocks/#create
     */
    create(params: CreateIpBlockParams): Promise<IpBlock>;
    /**
     * Change parameters for an existing IP block.
     * @param params Parameters
     * @return object of Ip Block
     * @see https://docs.joinmastodon.org/methods/admin/ip_blocks/#update
     */
    update(id: string, params: UpdateIpBlockParams): Promise<IpBlock>;
    /**
     * Lift a block against an IP range.
     * @param id id of ip block
     * @return null
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    remove(id: string): Promise<void>;
}

interface FetchMeasureParams {
    /**
     * Array of String. Request specific measures by their keystring. Supported measures include:
     *
     * `active_users` = Total active users on your instance within the time period
     *
     * `new_users` = Users who joined your instance within the time period
     *
     * `interactions` = Total interactions (favourites, boosts, replies) on local statuses within the time period
     *
     * `opened_reports` = Total reports filed within the time period
     *
     * `resolved_reports` = Total reports resolved within the time period
     *
     * `tag_accounts` = Total accounts who used a tag in at least one status within the time period
     *
     * `tag_uses` = Total statuses which used a tag within the time period
     *
     * `tag_servers` = Total remote origin servers for statuses which used a tag within the time period
     *
     * `instance_accounts` = Total accounts originating from a remote domain within the time period
     *
     * `instance_media_attachments` = Total space used by media attachments from a remote domain within the time period
     *
     * `instance_reports` = Total reports filed against accounts from a remote domain within the time period
     *
     * `instance_statuses` = Total statuses originating from a remote domain within the time period
     *
     * `instance_follows` = Total accounts from a remote domain followed by a local user within the time period
     *
     * `instance_followers` = Total local accounts followed by accounts from a remote domain within the time period
     */
    readonly keys: readonly MeasureKey[];
    /** String (ISO 8601 Datetime). The start date for the time period. If a time is provided, it will be ignored. */
    readonly startAt: string;
    /** String (ISO 8601 Datetime). The end date for the time period. If a time is provided, it will be ignored. */
    readonly endAt: string;
    readonly tagAccounts?: {
        /** String. When `tag_accounts` is one of the requested keys, you must provide a tag ID to obtain the measure of how many accounts used that hashtag in at least one status within the given time period. */
        readonly id?: string | null;
    } | null;
    readonly tagUses?: {
        /** String. When `tag_uses` is one of the requested keys, you must provide a tag ID to obtain the measure of how many statuses used that hashtag within the given time period. */
        readonly id?: string | null;
    } | null;
    readonly tagServers?: {
        /** String. When `tag_servers` is one of the requested keys, you must provide a tag ID to obtain the measure of how many servers used that hashtag in at least one status within the given time period. */
        readonly id?: string | null;
    } | null;
    readonly instanceAccounts?: {
        /** String. When `instance_accounts` is one of the requested keys, you must provide a remote domain to obtain the measure of how many accounts have been discovered from that server within the given time period. */
        readonly domain?: string | null;
    } | null;
    readonly instanceMediaAttachments?: {
        /** String. When `instance_media_attachments` is one of the requested keys, you must provide a remote domain to obtain the measure of how much space is used by media attachments from that server within the given time period. */
        readonly domain?: string | null;
    } | null;
    readonly instanceReports?: {
        /** String. When `instance_reports` is one of the requested keys, you must provide a remote domain to obtain the measure of how many reports have been filed against accounts from that server within the given time period. */
        readonly domain?: string | null;
    } | null;
    readonly instanceStatuses?: {
        /** String. When `instance_statuses` is one of the requested keys, you must provide a remote domain to obtain the measure of how many statuses originate from that server within the given time period. */
        readonly domain?: string | null;
    } | null;
    readonly instanceFollows?: {
        /** String. When `instance_follows` is one of the requested keys, you must provide a remote domain to obtain the measure of how many follows were performed on accounts from that server by local accounts within the given time period */
        readonly domain?: string | null;
    } | null;
    readonly instanceFollowers?: {
        /** String. When `instance_followers` is one of the requested keys, you must provide a remote domain to obtain the measure of how many follows were performed by accounts from that server on local accounts within the given time period. */
        readonly domain?: string | null;
    } | null;
}
declare class MeasureRepository {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Obtain quantitative metrics about the server.
     * @see https://docs.joinmastodon.org/methods/admin/measures/#get
     */
    fetch(params: FetchMeasureParams): Promise<Measure[]>;
}

interface ListReportsParams {
    readonly resolved?: boolean | null;
    readonly accountId?: string | null;
    readonly targetAccountId?: string | null;
    readonly byTargetDomain?: string | null;
}
declare class ReportRepository implements Repository<Report, never, never, never, ListReportsParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View all reports. Pagination may be done with HTTP Link header in the response.
     * @param params Parameters
     * @return Array of AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params?: ListReportsParams): Paginator<Report[], ListReportsParams>;
    /**
     * View information about the report with the given ID.
     * @param id ID of the report
     * @return AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    fetch(id: string): Promise<Report>;
    /**
     * Claim the handling of this report to yourself.
     * @param id ID of the report
     * @return AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    assignToSelf(id: string): Promise<Report>;
    /**
     * Unassign a report so that someone else can claim it.
     * @param id ID of the report
     * @return AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    unassign(id: string): Promise<Report>;
    /**
     * Mark a report as resolved with no further action taken.
     * @param id ID of the report
     * @return AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    resolve(id: string): Promise<Report>;
    /**
     * Reopen a currently closed report.
     * @param id ID of the report
     * @return AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    reopen(id: string): Promise<Report>;
}

interface CreateRetentionParams {
    /** String (ISO 8601 Datetime). The start date for the time period. If a time is provided, it will be ignored. */
    readonly startAt: string;
    /** String (ISO 8601 Datetime). The end date for the time period. If a time is provided, it will be ignored. */
    readonly endAt: string;
    /** String (Enumerable oneOf). Specify whether to use `day` or `month` buckets. If any other value is provided, defaults to `day`. */
    readonly frequency: CohortFrequency;
}
declare class RetentionRepository {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Generate a retention data report for a given time period and bucket.
     * @see https://docs.joinmastodon.org/methods/admin/retention/#create
     */
    create(params: CreateRetentionParams): Promise<Cohort[]>;
}

declare class TrendRepository {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Links that have been shared more than others, including unapproved and unreviewed links.
     * @see https://docs.joinmastodon.org/methods/admin/trends/#links
     */
    listLinks(): Paginator<TrendLink, undefined>;
    /**
     * Statuses that have been interacted with more than others, including unapproved and unreviewed statuses.
     * @see https://docs.joinmastodon.org/methods/admin/trends/#statuses
     */
    listStatuses(): Paginator<Status, undefined>;
    /**
     * Tags that are being used more frequently within the past week, including unapproved and unreviewed tags.
     * @see https://docs.joinmastodon.org/methods/admin/trends/#tags
     */
    listTags(): Paginator<Tag$1, undefined>;
}

type index$3_AccountActionType = AccountActionType;
type index$3_AccountRepository = AccountRepository;
declare const index$3_AccountRepository: typeof AccountRepository;
type index$3_CanonicalEmailBlockRepository = CanonicalEmailBlockRepository;
declare const index$3_CanonicalEmailBlockRepository: typeof CanonicalEmailBlockRepository;
type index$3_CreateActionParams = CreateActionParams;
type index$3_CreateCanonicalEmailBlockParams = CreateCanonicalEmailBlockParams;
type index$3_CreateCanonicalEmailBlockParamsWithCanonicalEmailHash = CreateCanonicalEmailBlockParamsWithCanonicalEmailHash;
type index$3_CreateCanonicalEmailBlockParamsWithEmail = CreateCanonicalEmailBlockParamsWithEmail;
type index$3_CreateDomainAllowParams = CreateDomainAllowParams;
type index$3_CreateDomainBlockParams = CreateDomainBlockParams;
type index$3_CreateEmailDomainBlockParams = CreateEmailDomainBlockParams;
type index$3_CreateIpBlockParams = CreateIpBlockParams;
type index$3_CreateRetentionParams = CreateRetentionParams;
type index$3_DimensionRepository = DimensionRepository;
declare const index$3_DimensionRepository: typeof DimensionRepository;
type index$3_DomainAllowRepository = DomainAllowRepository;
declare const index$3_DomainAllowRepository: typeof DomainAllowRepository;
type index$3_DomainBlockRepository = DomainBlockRepository;
declare const index$3_DomainBlockRepository: typeof DomainBlockRepository;
type index$3_EmailDomainBlockRepository = EmailDomainBlockRepository;
declare const index$3_EmailDomainBlockRepository: typeof EmailDomainBlockRepository;
type index$3_FetchDimensionParams = FetchDimensionParams;
type index$3_FetchMeasureParams = FetchMeasureParams;
type index$3_IpBlockRepository = IpBlockRepository;
declare const index$3_IpBlockRepository: typeof IpBlockRepository;
type index$3_ListAccountsParams = ListAccountsParams;
type index$3_ListDomainBlocksParams = ListDomainBlocksParams;
type index$3_ListEmailDomainBlocksParams = ListEmailDomainBlocksParams;
type index$3_ListIpBlocksParams = ListIpBlocksParams;
type index$3_ListReportsParams = ListReportsParams;
type index$3_MeasureRepository = MeasureRepository;
declare const index$3_MeasureRepository: typeof MeasureRepository;
type index$3_ReportRepository = ReportRepository;
declare const index$3_ReportRepository: typeof ReportRepository;
type index$3_RetentionRepository = RetentionRepository;
declare const index$3_RetentionRepository: typeof RetentionRepository;
type index$3_TestCanonicalEmailBlockParams = TestCanonicalEmailBlockParams;
type index$3_TrendRepository = TrendRepository;
declare const index$3_TrendRepository: typeof TrendRepository;
type index$3_UpdateDomainBlockParams = UpdateDomainBlockParams;
type index$3_UpdateIpBlockParams = UpdateIpBlockParams;
declare namespace index$3 {
  export {
    index$3_AccountActionType as AccountActionType,
    index$3_AccountRepository as AccountRepository,
    index$3_CanonicalEmailBlockRepository as CanonicalEmailBlockRepository,
    index$3_CreateActionParams as CreateActionParams,
    index$3_CreateCanonicalEmailBlockParams as CreateCanonicalEmailBlockParams,
    index$3_CreateCanonicalEmailBlockParamsWithCanonicalEmailHash as CreateCanonicalEmailBlockParamsWithCanonicalEmailHash,
    index$3_CreateCanonicalEmailBlockParamsWithEmail as CreateCanonicalEmailBlockParamsWithEmail,
    index$3_CreateDomainAllowParams as CreateDomainAllowParams,
    index$3_CreateDomainBlockParams as CreateDomainBlockParams,
    index$3_CreateEmailDomainBlockParams as CreateEmailDomainBlockParams,
    index$3_CreateIpBlockParams as CreateIpBlockParams,
    index$3_CreateRetentionParams as CreateRetentionParams,
    index$3_DimensionRepository as DimensionRepository,
    index$3_DomainAllowRepository as DomainAllowRepository,
    index$3_DomainBlockRepository as DomainBlockRepository,
    index$3_EmailDomainBlockRepository as EmailDomainBlockRepository,
    index$3_FetchDimensionParams as FetchDimensionParams,
    index$3_FetchMeasureParams as FetchMeasureParams,
    index$3_IpBlockRepository as IpBlockRepository,
    index$3_ListAccountsParams as ListAccountsParams,
    index$3_ListDomainBlocksParams as ListDomainBlocksParams,
    index$3_ListEmailDomainBlocksParams as ListEmailDomainBlocksParams,
    index$3_ListIpBlocksParams as ListIpBlocksParams,
    index$3_ListReportsParams as ListReportsParams,
    index$3_MeasureRepository as MeasureRepository,
    index$3_ReportRepository as ReportRepository,
    index$3_RetentionRepository as RetentionRepository,
    index$3_TestCanonicalEmailBlockParams as TestCanonicalEmailBlockParams,
    index$3_TrendRepository as TrendRepository,
    index$3_UpdateDomainBlockParams as UpdateDomainBlockParams,
    index$3_UpdateIpBlockParams as UpdateIpBlockParams,
  };
}

declare class AggregateRepositoryAdmin {
    private readonly http;
    private readonly config;
    private readonly logger?;
    readonly accounts: AccountRepository;
    readonly canonicalEmailBlocks: CanonicalEmailBlockRepository;
    readonly dimensions: DimensionRepository;
    readonly domainAllows: DomainAllowRepository;
    readonly domainBlocks: DomainBlockRepository;
    readonly emailDomainBlocks: EmailDomainBlockRepository;
    readonly ipBlocks: IpBlockRepository;
    readonly measures: MeasureRepository;
    readonly reports: ReportRepository;
    readonly retention: RetentionRepository;
    readonly trends: TrendRepository;
    /** @deprecated Use `accounts` instead */
    get account(): AccountRepository;
    /** @deprecated Use `reports` instead */
    get report(): ReportRepository;
    /** @deprecated Use `emailDomainBlocks` instead */
    get domainEmailBlocks(): EmailDomainBlockRepository;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
}

type SearchType$1 = 'accounts' | 'hashtags' | 'statuses';
interface SearchParams$1 extends DefaultPaginationParams {
    /** Attempt WebFinger lookup. Defaults to false. */
    readonly q: string;
    /** Enum(accounts, hashtags, statuses) */
    readonly type?: SearchType$1 | null;
    /** Attempt WebFinger look-up */
    readonly resolve?: boolean | null;
    /** If provided, statuses returned will be authored only by this account */
    readonly accountId?: string | null;
}
declare class AggregateRepository$1 {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    readonly admin: AggregateRepositoryAdmin;
    readonly stream: StreamRepository;
    readonly accounts: AccountRepository$1;
    readonly announcements: AnnouncementRepository;
    readonly apps: AppRepository;
    readonly blocks: BlockRepository;
    readonly bookmarks: BookmarkRepository;
    readonly conversations: ConversationRepository;
    readonly customEmojis: CustomEmojiRepository;
    readonly directory: DirectoryRepository;
    readonly domainBlocks: DomainBlockRepository$1;
    readonly endorsements: EndorsementRepository;
    readonly favourites: FavouriteRepository;
    readonly featuredTags: FeaturedTagRepository;
    readonly filters: FilterRepository$1;
    readonly followRequests: FollowRequestRepository;
    readonly instances: InstanceRepository$1;
    readonly lists: ListRepository;
    readonly markers: MarkerRepository;
    readonly mediaAttachments: MediaAttachmentRepository$1;
    readonly mutes: MuteRepository;
    readonly notifications: NotificationRepository;
    readonly polls: PollRepository;
    readonly preferences: PreferenceRepository;
    readonly webPushSubscriptions: WebPushSubscriptionRepository;
    readonly reports: ReportRepository$1;
    readonly scheduledStatuses: ScheduledStatusRepository;
    readonly statuses: StatusRepository;
    readonly suggestions: SuggestionRepository$1;
    readonly timelines: TimelineRepository;
    readonly trends: TrendRepository$1;
    readonly emails: EmailRepository;
    readonly tags: TagRepository;
    readonly followedTags: FollowedTagRepository;
    constructor(http: Http, ws: Ws, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Search, but hashtags is an array of strings instead of an array of Tag.
     * @param params Parameters
     * @return Results
     * @see https://docs.joinmastodon.org/methods/search/
     */
    search(params: SearchParams$1): Paginator<Search$1, SearchParams$1>;
}

type index$2_AccountCredentials = AccountCredentials;
type index$2_AccountField = AccountField;
type index$2_AccountSource = AccountSource;
type index$2_Activity = Activity;
type index$2_AddListAccountsParams = AddListAccountsParams;
type index$2_AggregateRepositoryAdmin = AggregateRepositoryAdmin;
declare const index$2_AggregateRepositoryAdmin: typeof AggregateRepositoryAdmin;
type index$2_Announcement = Announcement;
type index$2_AnnouncementAccount = AnnouncementAccount;
type index$2_AnnouncementRepository = AnnouncementRepository;
declare const index$2_AnnouncementRepository: typeof AnnouncementRepository;
type index$2_AnnouncementStatus = AnnouncementStatus;
type index$2_AppRepository = AppRepository;
declare const index$2_AppRepository: typeof AppRepository;
type index$2_Application = Application;
type index$2_BlockRepository = BlockRepository;
declare const index$2_BlockRepository: typeof BlockRepository;
type index$2_BookmarkRepository = BookmarkRepository;
declare const index$2_BookmarkRepository: typeof BookmarkRepository;
type index$2_Context = Context;
type index$2_Conversation = Conversation;
type index$2_ConversationRepository = ConversationRepository;
declare const index$2_ConversationRepository: typeof ConversationRepository;
type index$2_CreateAccountNoteParams = CreateAccountNoteParams;
type index$2_CreateAccountParams = CreateAccountParams;
type index$2_CreateAppParams = CreateAppParams;
type index$2_CreateConfirmationParams = CreateConfirmationParams;
type index$2_CreateFeaturedTagParams = CreateFeaturedTagParams;
type index$2_CreateListParams = CreateListParams;
type index$2_CreateMarkersParams = CreateMarkersParams;
type index$2_CreateScheduledStatusParams = CreateScheduledStatusParams;
type index$2_CreateStatusExtraParams = CreateStatusExtraParams;
type index$2_CreateStatusParams = CreateStatusParams;
type index$2_CreateStatusParamsBase = CreateStatusParamsBase;
type index$2_CreateStatusParamsWithMediaIds = CreateStatusParamsWithMediaIds;
type index$2_CreateStatusParamsWithStatus = CreateStatusParamsWithStatus;
type index$2_CreateStatusPollParam = CreateStatusPollParam;
type index$2_CreateWebPushSubscriptionParams = CreateWebPushSubscriptionParams;
type index$2_CustomEmoji = CustomEmoji;
type index$2_CustomEmojiRepository = CustomEmojiRepository;
declare const index$2_CustomEmojiRepository: typeof CustomEmojiRepository;
type index$2_DirectoryOrderType = DirectoryOrderType;
type index$2_DirectoryRepository = DirectoryRepository;
declare const index$2_DirectoryRepository: typeof DirectoryRepository;
type index$2_EmailRepository = EmailRepository;
declare const index$2_EmailRepository: typeof EmailRepository;
type index$2_EndorsementRepository = EndorsementRepository;
declare const index$2_EndorsementRepository: typeof EndorsementRepository;
type index$2_FamiliarFollowers = FamiliarFollowers;
type index$2_FavouriteRepository = FavouriteRepository;
declare const index$2_FavouriteRepository: typeof FavouriteRepository;
type index$2_FeaturedTag = FeaturedTag;
type index$2_FeaturedTagRepository = FeaturedTagRepository;
declare const index$2_FeaturedTagRepository: typeof FeaturedTagRepository;
type index$2_FetchMarkersParams = FetchMarkersParams;
type index$2_FilterKeyword = FilterKeyword;
type index$2_FilterResult = FilterResult;
type index$2_FilterStatus = FilterStatus;
type index$2_FollowAccountParams = FollowAccountParams;
type index$2_FollowRequestRepository = FollowRequestRepository;
declare const index$2_FollowRequestRepository: typeof FollowRequestRepository;
type index$2_FollowedTagRepository = FollowedTagRepository;
declare const index$2_FollowedTagRepository: typeof FollowedTagRepository;
type index$2_IdentityProof = IdentityProof;
type index$2_InstanceStats = InstanceStats;
type index$2_InstanceURLs = InstanceURLs;
type index$2_List = List;
type index$2_ListAccountStatusesParams = ListAccountStatusesParams;
type index$2_ListDirectoryParams = ListDirectoryParams;
type index$2_ListNotificationsParams = ListNotificationsParams;
type index$2_ListRepliesPolicy = ListRepliesPolicy;
type index$2_ListRepository = ListRepository;
declare const index$2_ListRepository: typeof ListRepository;
type index$2_ListSuggestionParams = ListSuggestionParams;
type index$2_ListTimelineParams = ListTimelineParams;
type index$2_ListTrendsParams = ListTrendsParams;
type index$2_LookupAccountParams = LookupAccountParams;
type index$2_Marker = Marker;
type index$2_MarkerItem = MarkerItem;
type index$2_MarkerRepository = MarkerRepository;
declare const index$2_MarkerRepository: typeof MarkerRepository;
type index$2_MarkerTimeline = MarkerTimeline;
type index$2_MediaAttachment = MediaAttachment;
type index$2_MediaAttachmentMeta = MediaAttachmentMeta;
type index$2_MediaAttachmentMetaColors = MediaAttachmentMetaColors;
type index$2_MediaAttachmentMetaFocus = MediaAttachmentMetaFocus;
type index$2_MediaAttachmentMetaImage = MediaAttachmentMetaImage;
type index$2_MediaAttachmentMetaVideo = MediaAttachmentMetaVideo;
type index$2_MediaAttachmentType = MediaAttachmentType;
type index$2_MuteAccountParams = MuteAccountParams;
type index$2_MuteRepository = MuteRepository;
declare const index$2_MuteRepository: typeof MuteRepository;
type index$2_Notification = Notification;
type index$2_NotificationRepository = NotificationRepository;
declare const index$2_NotificationRepository: typeof NotificationRepository;
type index$2_NotificationType = NotificationType;
type index$2_Poll = Poll;
type index$2_PollOption = PollOption;
type index$2_PollRepository = PollRepository;
declare const index$2_PollRepository: typeof PollRepository;
type index$2_Preference = Preference;
type index$2_PreferenceReadingExpandMedia = PreferenceReadingExpandMedia;
type index$2_PreferenceRepository = PreferenceRepository;
declare const index$2_PreferenceRepository: typeof PreferenceRepository;
type index$2_PreviewCard = PreviewCard;
type index$2_PreviewCardType = PreviewCardType;
type index$2_Reaction = Reaction;
type index$2_ReblogStatusParams = ReblogStatusParams;
type index$2_Relationship = Relationship;
type index$2_RemoveListAccountsParams = RemoveListAccountsParams;
type index$2_ReportAccountParams = ReportAccountParams;
type index$2_ReportCategory = ReportCategory;
type index$2_Role = Role;
type index$2_Rule = Rule;
type index$2_ScheduledStatus = ScheduledStatus;
type index$2_ScheduledStatusRepository = ScheduledStatusRepository;
declare const index$2_ScheduledStatusRepository: typeof ScheduledStatusRepository;
type index$2_SearchAccountsParams = SearchAccountsParams;
type index$2_Status = Status;
type index$2_StatusEdit = StatusEdit;
type index$2_StatusMention = StatusMention;
type index$2_StatusParams = StatusParams;
type index$2_StatusRepository = StatusRepository;
declare const index$2_StatusRepository: typeof StatusRepository;
type index$2_StatusSource = StatusSource;
type index$2_StatusVisibility = StatusVisibility;
type index$2_StreamRepository = StreamRepository;
declare const index$2_StreamRepository: typeof StreamRepository;
type index$2_SubscriptionPolicy = SubscriptionPolicy;
type index$2_Suggestion = Suggestion;
type index$2_SuggestionSource = SuggestionSource;
type index$2_Tag = Tag;
type index$2_TagHistory = TagHistory;
type index$2_TagRepository = TagRepository;
declare const index$2_TagRepository: typeof TagRepository;
type index$2_TimelineRepository = TimelineRepository;
declare const index$2_TimelineRepository: typeof TimelineRepository;
type index$2_Token = Token;
type index$2_TranslateStatusParams = TranslateStatusParams;
type index$2_Translation = Translation;
type index$2_TrendLink = TrendLink;
type index$2_UpdateCredentialsParams = UpdateCredentialsParams;
type index$2_UpdateListParams = UpdateListParams;
type index$2_UpdateMediaAttachmentParams = UpdateMediaAttachmentParams;
type index$2_UpdateScheduledStatusParams = UpdateScheduledStatusParams;
type index$2_UpdateStatusParams = UpdateStatusParams;
type index$2_UpdateWebPushSubscriptionParams = UpdateWebPushSubscriptionParams;
type index$2_VotePollParams = VotePollParams;
type index$2_WebPushSubscription = WebPushSubscription;
type index$2_WebPushSubscriptionAlerts = WebPushSubscriptionAlerts;
type index$2_WebPushSubscriptionPolicy = WebPushSubscriptionPolicy;
type index$2_WebPushSubscriptionRepository = WebPushSubscriptionRepository;
declare const index$2_WebPushSubscriptionRepository: typeof WebPushSubscriptionRepository;
declare namespace index$2 {
  export {
    Account$1 as Account,
    index$2_AccountCredentials as AccountCredentials,
    index$2_AccountField as AccountField,
    AccountRepository$1 as AccountRepository,
    index$2_AccountSource as AccountSource,
    index$2_Activity as Activity,
    index$2_AddListAccountsParams as AddListAccountsParams,
    index$4 as Admin,
    index$3 as AdminRepositories,
    AggregateRepository$1 as AggregateRepository,
    index$2_AggregateRepositoryAdmin as AggregateRepositoryAdmin,
    index$2_Announcement as Announcement,
    index$2_AnnouncementAccount as AnnouncementAccount,
    index$2_AnnouncementRepository as AnnouncementRepository,
    index$2_AnnouncementStatus as AnnouncementStatus,
    index$2_AppRepository as AppRepository,
    index$2_Application as Application,
    index$2_BlockRepository as BlockRepository,
    index$2_BookmarkRepository as BookmarkRepository,
    Client$1 as Client,
    index$2_Context as Context,
    index$2_Conversation as Conversation,
    index$2_ConversationRepository as ConversationRepository,
    index$2_CreateAccountNoteParams as CreateAccountNoteParams,
    index$2_CreateAccountParams as CreateAccountParams,
    index$2_CreateAppParams as CreateAppParams,
    index$2_CreateConfirmationParams as CreateConfirmationParams,
    index$2_CreateFeaturedTagParams as CreateFeaturedTagParams,
    CreateFilterParams$1 as CreateFilterParams,
    index$2_CreateListParams as CreateListParams,
    index$2_CreateMarkersParams as CreateMarkersParams,
    CreateMediaAttachmentParams$1 as CreateMediaAttachmentParams,
    index$2_CreateScheduledStatusParams as CreateScheduledStatusParams,
    index$2_CreateStatusExtraParams as CreateStatusExtraParams,
    index$2_CreateStatusParams as CreateStatusParams,
    index$2_CreateStatusParamsBase as CreateStatusParamsBase,
    index$2_CreateStatusParamsWithMediaIds as CreateStatusParamsWithMediaIds,
    index$2_CreateStatusParamsWithStatus as CreateStatusParamsWithStatus,
    index$2_CreateStatusPollParam as CreateStatusPollParam,
    index$2_CreateWebPushSubscriptionParams as CreateWebPushSubscriptionParams,
    index$2_CustomEmoji as CustomEmoji,
    index$2_CustomEmojiRepository as CustomEmojiRepository,
    index$2_DirectoryOrderType as DirectoryOrderType,
    index$2_DirectoryRepository as DirectoryRepository,
    DomainBlockRepository$1 as DomainBlockRepository,
    index$2_EmailRepository as EmailRepository,
    index$2_EndorsementRepository as EndorsementRepository,
    index$2_FamiliarFollowers as FamiliarFollowers,
    index$2_FavouriteRepository as FavouriteRepository,
    index$2_FeaturedTag as FeaturedTag,
    index$2_FeaturedTagRepository as FeaturedTagRepository,
    index$2_FetchMarkersParams as FetchMarkersParams,
    Filter$1 as Filter,
    FilterContext$1 as FilterContext,
    index$2_FilterKeyword as FilterKeyword,
    FilterRepository$1 as FilterRepository,
    index$2_FilterResult as FilterResult,
    index$2_FilterStatus as FilterStatus,
    index$2_FollowAccountParams as FollowAccountParams,
    index$2_FollowRequestRepository as FollowRequestRepository,
    index$2_FollowedTagRepository as FollowedTagRepository,
    index$2_IdentityProof as IdentityProof,
    Instance$1 as Instance,
    InstanceAccountsConfiguration$1 as InstanceAccountsConfiguration,
    InstanceConfiguration$1 as InstanceConfiguration,
    InstanceMediaAttachmentsConfiguration$1 as InstanceMediaAttachmentsConfiguration,
    InstancePollsConfiguration$1 as InstancePollsConfiguration,
    InstanceRepository$1 as InstanceRepository,
    index$2_InstanceStats as InstanceStats,
    InstanceStatusesConfiguration$1 as InstanceStatusesConfiguration,
    index$2_InstanceURLs as InstanceURLs,
    index$2_List as List,
    index$2_ListAccountStatusesParams as ListAccountStatusesParams,
    index$2_ListDirectoryParams as ListDirectoryParams,
    index$2_ListNotificationsParams as ListNotificationsParams,
    index$2_ListRepliesPolicy as ListRepliesPolicy,
    index$2_ListRepository as ListRepository,
    index$2_ListSuggestionParams as ListSuggestionParams,
    index$2_ListTimelineParams as ListTimelineParams,
    index$2_ListTrendsParams as ListTrendsParams,
    index$2_LookupAccountParams as LookupAccountParams,
    index$2_Marker as Marker,
    index$2_MarkerItem as MarkerItem,
    index$2_MarkerRepository as MarkerRepository,
    index$2_MarkerTimeline as MarkerTimeline,
    index$2_MediaAttachment as MediaAttachment,
    index$2_MediaAttachmentMeta as MediaAttachmentMeta,
    index$2_MediaAttachmentMetaColors as MediaAttachmentMetaColors,
    index$2_MediaAttachmentMetaFocus as MediaAttachmentMetaFocus,
    index$2_MediaAttachmentMetaImage as MediaAttachmentMetaImage,
    index$2_MediaAttachmentMetaVideo as MediaAttachmentMetaVideo,
    MediaAttachmentRepository$1 as MediaAttachmentRepository,
    index$2_MediaAttachmentType as MediaAttachmentType,
    index$2_MuteAccountParams as MuteAccountParams,
    index$2_MuteRepository as MuteRepository,
    index$2_Notification as Notification,
    index$2_NotificationRepository as NotificationRepository,
    index$2_NotificationType as NotificationType,
    index$2_Poll as Poll,
    index$2_PollOption as PollOption,
    index$2_PollRepository as PollRepository,
    index$2_Preference as Preference,
    index$2_PreferenceReadingExpandMedia as PreferenceReadingExpandMedia,
    index$2_PreferenceRepository as PreferenceRepository,
    index$2_PreviewCard as PreviewCard,
    index$2_PreviewCardType as PreviewCardType,
    index$2_Reaction as Reaction,
    index$2_ReblogStatusParams as ReblogStatusParams,
    index$2_Relationship as Relationship,
    index$2_RemoveListAccountsParams as RemoveListAccountsParams,
    index$2_ReportAccountParams as ReportAccountParams,
    index$2_ReportCategory as ReportCategory,
    ReportRepository$1 as ReportRepository,
    index$2_Role as Role,
    index$2_Rule as Rule,
    index$2_ScheduledStatus as ScheduledStatus,
    index$2_ScheduledStatusRepository as ScheduledStatusRepository,
    Search$1 as Search,
    index$2_SearchAccountsParams as SearchAccountsParams,
    SearchParams$1 as SearchParams,
    SearchType$1 as SearchType,
    index$2_Status as Status,
    index$2_StatusEdit as StatusEdit,
    index$2_StatusMention as StatusMention,
    index$2_StatusParams as StatusParams,
    index$2_StatusRepository as StatusRepository,
    index$2_StatusSource as StatusSource,
    index$2_StatusVisibility as StatusVisibility,
    index$2_StreamRepository as StreamRepository,
    index$2_SubscriptionPolicy as SubscriptionPolicy,
    index$2_Suggestion as Suggestion,
    SuggestionRepository$1 as SuggestionRepository,
    index$2_SuggestionSource as SuggestionSource,
    index$2_Tag as Tag,
    index$2_TagHistory as TagHistory,
    index$2_TagRepository as TagRepository,
    index$2_TimelineRepository as TimelineRepository,
    index$2_Token as Token,
    index$2_TranslateStatusParams as TranslateStatusParams,
    index$2_Translation as Translation,
    index$2_TrendLink as TrendLink,
    TrendRepository$1 as TrendRepository,
    index$2_UpdateCredentialsParams as UpdateCredentialsParams,
    UpdateFilterParams$1 as UpdateFilterParams,
    index$2_UpdateListParams as UpdateListParams,
    index$2_UpdateMediaAttachmentParams as UpdateMediaAttachmentParams,
    index$2_UpdateScheduledStatusParams as UpdateScheduledStatusParams,
    index$2_UpdateStatusParams as UpdateStatusParams,
    index$2_UpdateWebPushSubscriptionParams as UpdateWebPushSubscriptionParams,
    index$2_VotePollParams as VotePollParams,
    index$2_WebPushSubscription as WebPushSubscription,
    index$2_WebPushSubscriptionAlerts as WebPushSubscriptionAlerts,
    index$2_WebPushSubscriptionPolicy as WebPushSubscriptionPolicy,
    index$2_WebPushSubscriptionRepository as WebPushSubscriptionRepository,
  };
}

type FilterContext = 'home' | 'notifications' | 'public' | 'thread' | 'account';
type FilterAction = 'warn' | 'hide';
/**
 * Represents a user-defined filter for determining which statuses should not be shown to the user.
 * @see https://docs.joinmastodon.org/entities/filter/
 */
interface Filter {
    /** The ID of the filter in the database. */
    id: string;
    /** A title given by the user to name the filter. */
    title: string;
    /** The contexts in which the filter should be applied. */
    context: FilterContext[];
    /** When the filter should no longer be applied */
    expiresAt?: string | null;
    /**
     * The action to be taken when a status matches this filter.
     *
     * `warn` = show a warning that identifies the matching filter by title, and allow the user to expand the filtered status. This is the default (and unknown values should be treated as equivalent to warn).
     *
     * `hide` = do not show this status if it is received
     */
    filterAction: FilterAction;
    /** The keywords grouped under this filter. */
    keywords: FilterKeyword[];
    /** The statuses grouped under this filter. */
    statuses: FilterStatus[];
}

interface InstanceUsageUsers {
    /** The number of active users in the past 4 weeks. */
    activeMonth: number;
}
interface InstanceUsage {
    /** Usage data related to users on this instance. */
    users: InstanceUsageUsers;
}
interface InstanceThumbnailVersions {
    /** The URL for the thumbnail image at 1x resolution. */
    '@1x': string;
    /** The URL for the thumbnail image at 2x resolution. */
    '@2x': string;
}
interface InstanceThumbnail {
    /** The URL for the thumbnail image. */
    url: string;
    /** A hash computed by [the BlurHash algorithm](https://github.com/woltapp/blurhash), for generating colorful preview thumbnails when media has not been downloaded yet. */
    blurhash: string;
    /** Links to scaled resolution images, for high DPI screens. */
    versions: InstanceThumbnailVersions;
}
interface InstanceUrls {
    /** The WebSockets URL for connecting to the streaming API. */
    streamingApi: string;
    /** Instance status URL */
    status?: string;
}
interface InstanceAccountsConfiguration {
    /** The maximum number of featured tags allowed for each account. */
    maxFeaturedTags: number;
}
interface InstanceStatusesConfiguration {
    /** The maximum number of allowed characters per status. */
    maxCharacters: number;
    /** The maximum number of media attachments that can be added to a status. */
    maxMediaAttachments: number;
    /** Each URL in a status will be assumed to be exactly this many characters. */
    charactersReservedPerUrl: number;
}
interface InstanceMediaAttachmentsConfiguration {
    /** Contains MIME types that can be uploaded. */
    supportedMimeTypes: string[];
    /** The maximum size of any uploaded image, in bytes. */
    imageSizeLimit: number;
    /** The maximum number of pixels (width times height) for image uploads. */
    imageMatrixLimit: number;
    /** The maximum size of any uploaded video, in bytes. */
    videoSizeLimit: number;
    /** The maximum frame rate for any uploaded video. */
    videoFrameRateLimit: number;
    /** The maximum number of pixels (width times height) for video uploads. */
    videoMatrixLimit: number;
}
interface InstancePollsConfiguration {
    /** Each poll is allowed to have up to this many options. */
    maxOptions: number;
    /** Each poll option is allowed to have this many characters. */
    maxCharactersPerOption: number;
    /** The shortest allowed poll duration, in seconds. */
    minExpiration: number;
    /** The longest allowed poll duration, in seconds. */
    maxExpiration: number;
}
interface InstanceTranslationConfiguration {
    /** Whether the Translations API is available on this instance. */
    enabled: boolean;
}
interface InstanceConfiguration {
    /** URLs of interest for clients apps. */
    urls: InstanceUrls;
    /** Limits related to accounts. */
    accounts: InstanceAccountsConfiguration;
    /** Limits related to authoring statuses. */
    statuses: InstanceStatusesConfiguration;
    /** Hints for which attachments will be accepted. */
    mediaAttachments: InstanceMediaAttachmentsConfiguration;
    /** Limits related to polls. */
    polls: InstancePollsConfiguration;
    /** Hints related to translation. */
    translation: InstanceTranslationConfiguration;
}
interface InstanceRegistrations {
    /** Whether registrations are enabled. */
    enabled: boolean;
    /** Whether registrations require moderator approval. */
    approvalRequired: boolean;
    /** A custom message to be shown when registrations are closed. */
    message?: string | null;
}
interface InstanceContact {
    /** An email address that can be messaged regarding inquiries or issues. */
    email: string;
    /** An account that can be contacted natively over the network regarding inquiries or issues. */
    account: Account$1;
}
/**
 * Represents the software instance of Mastodon running on this domain.
 * @see https://docs.joinmastodon.org/entities/Instance/
 */
interface Instance {
    /** The domain name of the instance. */
    domain: string;
    /** The title of the website. */
    title: string;
    /** The version of Mastodon installed on the instance. */
    version: string;
    /** The URL for the source code of the software running on this instance, in keeping with AGPL license requirements. */
    sourceUrl: string;
    /** A short, plain-text description defined by the admin. */
    description: string;
    /** Usage data for this instance. */
    usage: InstanceUsage;
    /** An image used to represent this instance */
    thumbnail: InstanceThumbnail;
    /** Primary languages of the website and its staff. */
    languages: string[];
    /** Configured values and limits for this website. */
    configuration: InstanceConfiguration;
    /** Information about registering for this website. */
    registrations: InstanceRegistrations;
    /** Hints related to contacting a representative of the website. */
    contact: InstanceContact;
    /** An itemized list of rules for this website. */
    rules: Rule[];
}

/**
 * Represents the results of a search.
 * @see https://docs.joinmastodon.org/entities/Search/
 */
interface Search {
    /** Accounts which match the given query */
    accounts: Account$1[];
    /** Statuses which match the given query */
    statuses: Status[];
    /** Hashtags which match the given query */
    hashtags: Tag[];
}

interface CreateFilterParams {
    /** String. The name of the filter group. */
    readonly title: string;
    /** Array of String. Where the filter should be applied. Specify at least one of home, notifications, public, thread, account. */
    readonly context: readonly FilterContext[] | null;
    /** String. The policy to be applied when the filter is matched. Specify warn or hide. */
    readonly filterAction?: FilterAction | null;
    /** Integer. How many seconds from now should the filter expire? */
    readonly expiresIn?: number | null;
    readonly keywordsAttributes?: readonly {
        /** String. A keyword to be added to the newly-created filter group. */
        readonly keyword?: string | null;
        /** Boolean. Whether the keyword should consider word boundaries. */
        readonly wholeWord?: boolean | null;
    }[];
}
interface UpdateFilterParams {
    /** String. The name of the filter group. */
    readonly title?: string;
    /** Array of String. Where the filter should be applied. Specify at least one of home, notifications, public, thread, account. */
    readonly context?: readonly FilterContext[] | null;
    /** String. The policy to be applied when the filter is matched. Specify warn or hide. */
    readonly filterAction?: FilterAction | null;
    /** Integer. How many seconds from now should the filter expire? */
    readonly expiresIn?: number | null;
    readonly keywordsAttributes?: readonly {
        /** String. Provide the ID of an existing keyword to modify it, instead of creating a new keyword. */
        readonly id?: string | null;
        /** String. A keyword to be added to the newly-created filter group. */
        readonly keyword?: string | null;
        /** Boolean. Whether the keyword should consider word boundaries. */
        readonly wholeWord?: boolean | null;
        /** Boolean. If true, will remove the keyword with the given ID */
        readonly _destroy?: boolean | null;
    }[];
}
interface CreateFilterKeywordParams {
    /** String. The keyword to be added to the filter group. */
    readonly keyword: string;
    /** Boolean. Whether the keyword should consider word boundaries. */
    readonly wholeWord?: boolean | null;
}
type UpdateFilterKeywordParams = CreateFilterKeywordParams;
interface CreateFilterStatusParams {
    readonly statusId: string;
}
declare class FilterRepository implements Repository<Filter, CreateFilterParams, UpdateFilterParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View all filters
     * @return Array of Filter
     * @see https://docs.joinmastodon.org/methods/filters/#get
     */
    list(): Paginator<Filter[]>;
    /**
     * Obtain a single filter group owned by the current user.
     * @param id ID of the filter
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/filters/#get-one
     */
    fetch(id: string): Promise<Filter>;
    /**
     * Create a filter group with the given parameters.
     * @param params Parameters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/filters/#create
     */
    create(params?: CreateFilterParams): Promise<Filter>;
    /**
     * Update a filter group with the given parameters.
     * @param id ID of the filter in the database
     * @param params Parameters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/filters/#update
     */
    update(id: string, params?: UpdateFilterParams): Promise<Filter>;
    /**
     * Delete a filter group with the given id.
     * @param id ID of the filter in the database
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/filters/#delete
     */
    remove(id: string): Promise<void>;
    /**
     * List all keywords attached to the current filter group.
     * @param id String. The ID of the Filter in the database.
     * @returns Array of FilterKeyword
     * @see https://docs.joinmastodon.org/methods/filters/#keywords-get
     */
    listKeywords(id: string): Paginator<FilterKeyword[]>;
    /**
     * Add the given keyword to the specified filter group
     * @param id String. The ID of the Filter in the database.
     * @param params Parameters
     * @return FilterKeywords
     * @see https://docs.joinmastodon.org/methods/filters/#keywords-create
     */
    createKeyword(id: string, params: CreateFilterKeywordParams): Promise<FilterKeyword>;
    /**
     * Get one filter keyword by the given id.
     * @param id String. The ID of the FilterKeyword in the database.
     * @returns FilterKeyword
     * @see https://docs.joinmastodon.org/methods/filters/#keywords-get-one
     */
    fetchKeyword(id: string): Paginator<FilterKeyword>;
    /**
     * Update the given filter keyword.
     * @param id String. The ID of the FilterKeyword in the database.
     * @param params Parameters
     * @return FilterKeywords
     * @see https://docs.joinmastodon.org/methods/filters/#keywords-update
     */
    updateKeyword(id: string, params: CreateFilterKeywordParams): Promise<FilterKeyword>;
    /**
     * Deletes the given filter keyword.
     * @param id String. The ID of the FilterKeyword in the database.
     * @returns empty object
     * @see https://docs.joinmastodon.org/methods/filters/#keywords-delete
     */
    removeKeyword(id: string): Promise<void>;
    /**
     * Obtain a list of all status filters within this filter group.
     * @param id String. The ID of the Filter in the database.
     * @returns Array of FilterStatus
     * @see https://docs.joinmastodon.org/methods/filters/#statuses-get
     */
    listStatuses(id: string): Paginator<FilterStatus[]>;
    /**
     * Add a status filter to the current filter group.
     * @param id String. The ID of the Filter in the database.
     * @param params
     * @returns FilterStatus
     * @see https://docs.joinmastodon.org/methods/filters/#statuses-add
     */
    createStatus(id: string, params: CreateFilterStatusParams): Promise<FilterStatus>;
    /**
     * Obtain a single status filter.
     * @param id String. The ID of the FilterStatus in the database.
     * @returns FilterStatus
     * @see https://docs.joinmastodon.org/methods/filters/#statuses-get-one
     */
    fetchStatus(id: string): Promise<FilterStatus>;
    /**
     * @param id String. The ID of the FilterStatus in the database.
     * @returns FilterStatus
     * @see https://docs.joinmastodon.org/methods/filters/#statuses-get-one
     */
    removeStatus(id: string): Promise<FilterStatus>;
}

declare class InstanceRepository implements Repository<Instance> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Information about the server.
     * @return Instance
     * @see https://docs.joinmastodon.org/methods/instance/
     */
    fetch(): Promise<Instance>;
}

interface CreateMediaAttachmentParams {
    /** The file to be attached, using multipart form data. */
    readonly file: unknown;
    /** A plain-text description of the media, for accessibility purposes. */
    readonly description?: string | null;
    /** Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0 */
    readonly focus?: string | null;
    /** Custom thumbnail */
    readonly thumbnail?: unknown | null;
}
interface CreateMediaAttachmentExtraParams {
    /** Wait resolving promise for the media to be uploaded. Defaults to `false` */
    readonly skipPolling?: boolean;
}
declare class MediaAttachmentRepository {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    private readonly v1;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * @experimental
     * @param id ID of the media
     * @param interval interval of polling
     * @returns Media attachment that has done processing
     */
    waitFor(id: string, interval?: number): Promise<MediaAttachment>;
    /**
     * Creates an attachment to be used with a new status.
     * @param params Parameters
     * @return Attachment
     * @see https://docs.joinmastodon.org/methods/statuses/media/
     */
    create(params: CreateMediaAttachmentParams, extra?: CreateMediaAttachmentExtraParams): Promise<MediaAttachment>;
}

interface ListSuggestionsParams {
    /** Integer. Maximum number of results to return. Defaults to 40. */
    readonly limit?: number | null;
}
declare class SuggestionRepository implements Repository<Suggestion, never, never, never, ListSuggestionsParams> {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * View follow suggestions.
     * Accounts that are promoted by staff, or that the user has had past positive interactions with, but is not yet following.
     * @param params
     * @returns
     */
    list(params?: ListSuggestionsParams): Paginator<Suggestion[], ListSuggestionsParams>;
}

type SearchType = 'accounts' | 'hashtags' | 'statuses';
interface SearchParams extends DefaultPaginationParams {
    /** Attempt WebFinger lookup. Defaults to false. */
    readonly q: string;
    /** Enum(accounts, hashtags, statuses) */
    readonly type?: SearchType | null;
    /** Attempt WebFinger look-up */
    readonly resolve?: boolean | null;
    /** If provided, statuses returned will be authored only by this account */
    readonly accountId?: string | null;
    /** Filter out unreviewed tags? Defaults to false. Use true when trying to find trending tags. */
    readonly excludeUnreviewed?: boolean | null;
    /** Only include accounts that the user is following. Defaults to false. */
    readonly following?: boolean | null;
}
declare class AggregateRepository {
    private readonly http;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    readonly filters: FilterRepository;
    readonly instance: InstanceRepository;
    readonly mediaAttachments: MediaAttachmentRepository;
    readonly suggestions: SuggestionRepository;
    constructor(http: Http, config: MastoConfig, logger?: Logger | undefined);
    /**
     * Perform a search
     * @param params Parameters
     * @return Results
     * @see https://docs.joinmastodon.org/methods/search/
     */
    search(params: SearchParams): Paginator<Search, SearchParams>;
}

type index$1_AggregateRepository = AggregateRepository;
declare const index$1_AggregateRepository: typeof AggregateRepository;
type index$1_CreateFilterKeywordParams = CreateFilterKeywordParams;
type index$1_CreateFilterParams = CreateFilterParams;
type index$1_CreateFilterStatusParams = CreateFilterStatusParams;
type index$1_CreateMediaAttachmentExtraParams = CreateMediaAttachmentExtraParams;
type index$1_CreateMediaAttachmentParams = CreateMediaAttachmentParams;
type index$1_Filter = Filter;
type index$1_FilterAction = FilterAction;
type index$1_FilterContext = FilterContext;
type index$1_FilterRepository = FilterRepository;
declare const index$1_FilterRepository: typeof FilterRepository;
type index$1_Instance = Instance;
type index$1_InstanceAccountsConfiguration = InstanceAccountsConfiguration;
type index$1_InstanceConfiguration = InstanceConfiguration;
type index$1_InstanceContact = InstanceContact;
type index$1_InstanceMediaAttachmentsConfiguration = InstanceMediaAttachmentsConfiguration;
type index$1_InstancePollsConfiguration = InstancePollsConfiguration;
type index$1_InstanceRegistrations = InstanceRegistrations;
type index$1_InstanceRepository = InstanceRepository;
declare const index$1_InstanceRepository: typeof InstanceRepository;
type index$1_InstanceStatusesConfiguration = InstanceStatusesConfiguration;
type index$1_InstanceThumbnail = InstanceThumbnail;
type index$1_InstanceThumbnailVersions = InstanceThumbnailVersions;
type index$1_InstanceTranslationConfiguration = InstanceTranslationConfiguration;
type index$1_InstanceUrls = InstanceUrls;
type index$1_InstanceUsage = InstanceUsage;
type index$1_InstanceUsageUsers = InstanceUsageUsers;
type index$1_ListSuggestionsParams = ListSuggestionsParams;
type index$1_MediaAttachmentRepository = MediaAttachmentRepository;
declare const index$1_MediaAttachmentRepository: typeof MediaAttachmentRepository;
type index$1_Search = Search;
type index$1_SearchParams = SearchParams;
type index$1_SearchType = SearchType;
type index$1_SuggestionRepository = SuggestionRepository;
declare const index$1_SuggestionRepository: typeof SuggestionRepository;
type index$1_UpdateFilterKeywordParams = UpdateFilterKeywordParams;
type index$1_UpdateFilterParams = UpdateFilterParams;
declare namespace index$1 {
  export {
    index$1_AggregateRepository as AggregateRepository,
    index$1_CreateFilterKeywordParams as CreateFilterKeywordParams,
    index$1_CreateFilterParams as CreateFilterParams,
    index$1_CreateFilterStatusParams as CreateFilterStatusParams,
    index$1_CreateMediaAttachmentExtraParams as CreateMediaAttachmentExtraParams,
    index$1_CreateMediaAttachmentParams as CreateMediaAttachmentParams,
    index$1_Filter as Filter,
    index$1_FilterAction as FilterAction,
    index$1_FilterContext as FilterContext,
    index$1_FilterRepository as FilterRepository,
    index$1_Instance as Instance,
    index$1_InstanceAccountsConfiguration as InstanceAccountsConfiguration,
    index$1_InstanceConfiguration as InstanceConfiguration,
    index$1_InstanceContact as InstanceContact,
    index$1_InstanceMediaAttachmentsConfiguration as InstanceMediaAttachmentsConfiguration,
    index$1_InstancePollsConfiguration as InstancePollsConfiguration,
    index$1_InstanceRegistrations as InstanceRegistrations,
    index$1_InstanceRepository as InstanceRepository,
    index$1_InstanceStatusesConfiguration as InstanceStatusesConfiguration,
    index$1_InstanceThumbnail as InstanceThumbnail,
    index$1_InstanceThumbnailVersions as InstanceThumbnailVersions,
    index$1_InstanceTranslationConfiguration as InstanceTranslationConfiguration,
    index$1_InstanceUrls as InstanceUrls,
    index$1_InstanceUsage as InstanceUsage,
    index$1_InstanceUsageUsers as InstanceUsageUsers,
    index$1_ListSuggestionsParams as ListSuggestionsParams,
    index$1_MediaAttachmentRepository as MediaAttachmentRepository,
    index$1_Search as Search,
    index$1_SearchParams as SearchParams,
    index$1_SearchType as SearchType,
    index$1_SuggestionRepository as SuggestionRepository,
    index$1_UpdateFilterKeywordParams as UpdateFilterKeywordParams,
    index$1_UpdateFilterParams as UpdateFilterParams,
  };
}

interface CreateTokenParamsWithPassword {
    readonly grantType: 'password';
    readonly clientId: string;
    readonly clientSecret: string;
    readonly username: string;
    readonly password: string;
    readonly scope?: string;
}
type CreateTokenParams = CreateTokenParamsWithPassword;
/**
 * @experimental
 */
declare class OAuthRepository {
    private readonly http;
    constructor(http: Http);
    createToken(params: CreateTokenParams): Promise<Token>;
}

declare class Client {
    readonly http: Http;
    readonly ws: Ws;
    readonly config: MastoConfig;
    readonly logger?: Logger | undefined;
    readonly v1: AggregateRepository$1;
    readonly v2: AggregateRepository;
    readonly oauth: OAuthRepository;
    constructor(http: Http, ws: Ws, config: MastoConfig, logger?: Logger | undefined);
}

type index_Client = Client;
declare const index_Client: typeof Client;
type index_DefaultPaginationParams = DefaultPaginationParams;
type index_Repository<Entity, CreateParams = never, UpdateParams = never, FetchParams = never, ListParams = undefined> = Repository<Entity, CreateParams, UpdateParams, FetchParams, ListParams>;
declare namespace index {
  export {
    index_Client as Client,
    index_DefaultPaginationParams as DefaultPaginationParams,
    index_Repository as Repository,
    index$2 as v1,
    index$1 as v2,
  };
}

type RequestParams = Pick<MastoConfigProps, 'url' | 'logLevel' | 'timeout' | 'defaultRequestInit' | 'disableDeprecatedWarning'>;
declare const fetchV1Instance: (params: RequestParams) => Promise<Instance$1>;
declare const fetchV2Instance: (params: RequestParams) => Promise<Instance>;
type CreateClientParams = Omit<MastoConfigProps, 'version'> & {
    readonly version?: string;
};
declare const createClient: (params: CreateClientParams) => Client;
type LoginParams = Omit<CreateClientParams, 'streamingApiUrl' | 'version'>;
/**
 * Fetching instance information and create a client
 *
 * Shortcut of `fetchV1Instance` and `createClient`
 */
declare const login: (params: LoginParams) => Promise<Client>;

export { BaseHttp, BaseLogger, CreateClientParams, Event, EventType, EventTypeMap, Http, HttpMethod, HttpNativeImpl, HttpRequestParams, HttpRequestResult, LogLevel, LogType, Logger, LoggerConsoleImpl, LoginParams, MastoConfig, MastoConfigProps, Paginator, RequestParams, Serializer, SerializerNativeImpl, Ws, WsEventHandler, WsEvents, WsEventsNativeImpl, WsNativeImpl, createClient, fetchV1Instance, fetchV2Instance, login, index as mastodon };
