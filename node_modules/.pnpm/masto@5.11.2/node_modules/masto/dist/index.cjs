'use strict';

var ponyfills = require('@mastojs/ponyfills');
var semver = require('semver');
var qs = require('qs');
var changeCase = require('change-case');
var EventEmitter = require('eventemitter3');
var WebSocket = require('isomorphic-ws');

/**
 * Error object
 * @see https://docs.joinmastodon.org/entities/error/
 */
class MastoError extends Error {
    /**
     * @param message The error message. Equivalent for the `error` field from the Error entity
     * @param props Additional properties
     */
    constructor(message, props = {}) {
        super(message, { cause: props.cause });
        this.name = 'MastoError';
        /** Helper to check if the error has been thrown from Masto */
        this.isMastoError = true;
        Object.setPrototypeOf(this, MastoError.prototype);
        this.description = props.description;
        this.details = props.details;
    }
}

class MastoHttpError extends MastoError {
    constructor(message, statusCode, props) {
        super(message, props);
        this.name = 'MastoHttpError';
        Object.setPrototypeOf(this, MastoHttpError.prototype);
        this.statusCode = statusCode;
    }
}

/**
 * Mastodon forbidden error
 */
class MastoHttpConflictError extends MastoHttpError {
    constructor(message, props) {
        super(message, 409, props);
        this.name = 'MastoHttpConflictError';
        Object.setPrototypeOf(this, MastoHttpConflictError.prototype);
    }
}

/**
 * Mastodon forbidden error
 */
class MastoHttpForbiddenError extends MastoHttpError {
    constructor(message, props) {
        super(message, 403, props);
        this.name = 'MastoHttpForbiddenError';
        Object.setPrototypeOf(this, MastoHttpForbiddenError.prototype);
    }
}

/**
 * Mastodon gone error
 */
class MastoHttpGoneError extends MastoHttpError {
    constructor(message, props) {
        super(message, 410, props);
        this.name = 'MastoHttpGoneError';
        Object.setPrototypeOf(this, MastoHttpGoneError.prototype);
    }
}

/**
 * Mastodon not found error class
 */
class MastoHttpNotFoundError extends MastoHttpError {
    constructor(message, props) {
        super(message, 404, props);
        this.name = 'MastoHttpNotFoundError';
        Object.setPrototypeOf(this, MastoHttpNotFoundError.prototype);
    }
}

/**
 * Mastodon rate limit error class
 */
class MastoHttpRateLimitError extends MastoHttpError {
    constructor(message, props) {
        super(message, 429, props);
        this.name = 'MastoHttpRateLimitError';
        Object.setPrototypeOf(this, MastoHttpRateLimitError.prototype);
        this.limit = props.limit;
        this.remaining = props.remaining;
        this.reset = props.reset;
    }
}

/**
 * Mastodon unauthorized error class
 */
class MastoHttpUnauthorizedError extends MastoHttpError {
    constructor(message, props) {
        super(message, 401, props);
        this.name = 'MastoHttpUnauthorizedError';
        Object.setPrototypeOf(this, MastoHttpUnauthorizedError.prototype);
    }
}

class MastoHttpUnexpectedError extends MastoHttpError {
    constructor(message, statusCode, props) {
        super(message, statusCode, props);
        this.name = 'MastoHttpUnexpectedError';
        Object.setPrototypeOf(this, MastoHttpUnexpectedError.prototype);
    }
}

/**
 * Mastodon unprocessable entity
 */
class MastoHttpUnprocessableEntityError extends MastoHttpError {
    constructor(message, props) {
        super(message, 422, props);
        this.name = 'MastoHttpUnprocessableEntityError';
        Object.setPrototypeOf(this, MastoHttpUnprocessableEntityError.prototype);
    }
}

const createHttpError = (params) => {
    var _a, _b;
    const message = (_a = params.message) !== null && _a !== void 0 ? _a : 'Unexpected error occurred';
    const props = {
        cause: params.cause,
        description: (_b = params.description) !== null && _b !== void 0 ? _b : 'No further description is provided for this error',
        details: params.details,
    };
    switch (params.statusCode) {
        case 401: {
            return new MastoHttpUnauthorizedError(message, props);
        }
        case 403: {
            return new MastoHttpForbiddenError(message, props);
        }
        case 404: {
            return new MastoHttpNotFoundError(message, props);
        }
        case 409: {
            return new MastoHttpConflictError(message, props);
        }
        case 410: {
            return new MastoHttpGoneError(message, props);
        }
        case 422: {
            return new MastoHttpUnprocessableEntityError(message, props);
        }
        case 429: {
            return new MastoHttpRateLimitError(message, Object.assign(Object.assign({}, props), { limit: params.limit, remaining: params.remaining, reset: params.reset }));
        }
        default: {
            return new MastoHttpUnexpectedError(message, params.statusCode, props);
        }
    }
};

class MastoUnexpectedError extends MastoError {
    constructor(message, props = {}) {
        super(message, { cause: props.cause });
        this.name = 'MastoUnexpectedError';
        Object.setPrototypeOf(this, MastoUnexpectedError.prototype);
    }
}

/**
 * Mastodon Deserialize error
 */
class MastoDeserializeError extends MastoError {
    constructor(message, contentType, data, props) {
        super(message, props);
        this.contentType = contentType;
        this.data = data;
        this.name = 'MastoDeserializeError';
        Object.setPrototypeOf(this, MastoDeserializeError.prototype);
    }
}

/**
 * Mastodon version error
 */
class MastoVersionError extends MastoError {
    constructor(message, props) {
        super(message, props);
        this.name = 'MastoVersionError';
        Object.setPrototypeOf(this, MastoVersionError.prototype);
    }
}

/**
 * Mastodon invalid argument error
 */
class MastoInvalidArgumentError extends MastoError {
    constructor(message, props) {
        super(message, props);
        this.name = 'MastoInvalidArgumentError';
        Object.setPrototypeOf(this, MastoInvalidArgumentError.prototype);
    }
}

/**
 * Mastodon Timeout error
 */
class MastoTimeoutError extends MastoError {
    constructor(message, props) {
        super(message, props);
        this.name = 'MastoTimeoutError';
        Object.setPrototypeOf(this, MastoTimeoutError.prototype);
    }
}

class BaseLogger {
    constructor(logLevel) {
        this.logLevel = logLevel;
    }
    debug(message, meta) {
        if (this.logLevel.satisfies('debug')) {
            this.log('debug', message, meta);
        }
    }
    info(message, meta) {
        if (this.logLevel.satisfies('info')) {
            this.log('info', message, meta);
        }
    }
    warn(message, meta) {
        if (this.logLevel.satisfies('warn')) {
            this.log('warn', message, meta);
        }
    }
    error(message, meta) {
        if (this.logLevel.satisfies('error')) {
            this.log('error', message, meta);
        }
    }
}

/* eslint-disable no-console */
class LoggerConsoleImpl extends BaseLogger {
    constructor(logLevel) {
        super(logLevel);
    }
    log(type, message, meta) {
        switch (type) {
            case 'debug': {
                console.debug(message, meta);
                return;
            }
            case 'info': {
                console.info(message, meta);
                return;
            }
            case 'warn': {
                console.warn(message, meta);
                return;
            }
            case 'error': {
                console.error(message, meta);
                return;
            }
        }
    }
}

/* eslint-disable unicorn/prefer-math-trunc */
const LOG_TYPES = Object.freeze({
    DEBUG: 1 << 0,
    INFO: 1 << 1,
    WARN: 1 << 2,
    ERROR: 1 << 3,
});
class LogLevel {
    constructor(level) {
        this.level = level;
    }
    satisfies(type) {
        switch (type) {
            case 'debug': {
                return Boolean(this.level & LOG_TYPES.DEBUG);
            }
            case 'info': {
                return Boolean(this.level & LOG_TYPES.INFO);
            }
            case 'warn': {
                return Boolean(this.level & LOG_TYPES.WARN);
            }
            case 'error': {
                return Boolean(this.level & LOG_TYPES.ERROR);
            }
        }
    }
    static from(type) {
        switch (type) {
            case 'debug': {
                return new LogLevel(LOG_TYPES.DEBUG | LOG_TYPES.INFO | LOG_TYPES.WARN | LOG_TYPES.ERROR);
            }
            case 'info': {
                return new LogLevel(LOG_TYPES.INFO | LOG_TYPES.WARN | LOG_TYPES.ERROR);
            }
            case 'warn': {
                return new LogLevel(LOG_TYPES.WARN | LOG_TYPES.ERROR);
            }
            case 'error': {
                return new LogLevel(LOG_TYPES.ERROR);
            }
        }
    }
}

const delay = (ms) => new Promise((resolve) => setTimeout(() => resolve(), ms));

class Timeout {
    constructor(millisecond) {
        this.abortController = new ponyfills.AbortController();
        this.timeout = setTimeout(() => {
            this.abortController.abort();
        }, millisecond);
    }
    get signal() {
        return this.abortController.signal;
    }
    clear() {
        clearTimeout(this.timeout);
    }
}

const mergeAbortSignals = (signals) => {
    const abortController = new ponyfills.AbortController();
    for (const signal of signals) {
        signal.addEventListener('abort', () => abortController.abort());
    }
    return abortController.signal;
};

/* eslint-disable unicorn/no-array-for-each */
const mergeHeadersInit = ([head, ...tail]) => {
    const headers = new ponyfills.Headers(head);
    for (const entry of tail) {
        new ponyfills.Headers(entry).forEach((value, key) => {
            headers.set(key, value);
        });
    }
    return headers;
};

const DEFAULT_TIMEOUT_MS = 1000 * 300;
class MastoConfig {
    constructor(props, serializer) {
        this.props = props;
        this.serializer = serializer;
    }
    createHeader(override = {}) {
        var _a, _b;
        const headersInit = mergeHeadersInit([
            (_b = (_a = this.props.defaultRequestInit) === null || _a === void 0 ? void 0 : _a.headers) !== null && _b !== void 0 ? _b : {},
            { 'Content-Type': 'application/json' },
            override,
        ]);
        const headers = new ponyfills.Headers(headersInit);
        if (this.props.accessToken) {
            headers.set('Authorization', `Bearer ${this.props.accessToken}`);
        }
        return new ponyfills.Headers(headers);
    }
    createWebsocketProtocols(protocols = []) {
        return this.supportsSecureToken() && this.props.accessToken != undefined
            ? [this.props.accessToken, ...protocols]
            : protocols;
    }
    resolveHttpPath(path, params) {
        const url = new URL(path, this.props.url);
        if (params) {
            url.search = this.serializer.serializeQueryString(params);
        }
        return url;
    }
    resolveWebsocketPath(path, params = {}) {
        if (this.props.streamingApiUrl == undefined) {
            throw new MastoInvalidArgumentError('You need to specify `streamingApiUrl` to use this feature');
        }
        const url = new URL(this.props.streamingApiUrl.replace(/\/$/, '') + path);
        if (!this.supportsSecureToken()) {
            params.accessToken = this.props.accessToken;
        }
        url.search = this.serializer.serializeQueryString(params);
        return url.toString();
    }
    createTimeout() {
        var _a;
        return new Timeout((_a = this.props.timeout) !== null && _a !== void 0 ? _a : DEFAULT_TIMEOUT_MS);
    }
    createAbortSignal(signal) {
        var _a;
        const timeout = this.createTimeout();
        const signals = [timeout.signal];
        if ((_a = this.props.defaultRequestInit) === null || _a === void 0 ? void 0 : _a.signal) {
            // FIXME: `abort-controller` and `node-fetch` mismatches
            signals.push(this.props.defaultRequestInit.signal);
        }
        if (signal != undefined) {
            signals.push(signal);
        }
        return [mergeAbortSignals(signals), timeout];
    }
    getLogLevel() {
        var _a;
        return LogLevel.from((_a = this.props.logLevel) !== null && _a !== void 0 ? _a : 'warn');
    }
    shouldWarnDeprecated() {
        return !this.props.disableDeprecatedWarning;
    }
    satisfiesVersion(since, until) {
        var _a;
        if (this.props.version == undefined || this.props.disableVersionCheck) {
            return {
                compat: 'compatible',
                version: (_a = this.props.version) === null || _a === void 0 ? void 0 : _a.version,
            };
        }
        if (since && semver.lt(this.props.version, since)) {
            return {
                compat: 'unimplemented',
                version: this.props.version.version,
            };
        }
        if (until && semver.gt(this.props.version, until)) {
            return {
                compat: 'removed',
                version: this.props.version.version,
            };
        }
        return {
            compat: 'compatible',
            version: this.props.version.version,
        };
    }
    supportsSecureToken() {
        var _a;
        if (this.props.version == undefined || this.props.disableVersionCheck) {
            return true;
        }
        // Since v2.8.4, it is supported to pass access token with`Sec-Websocket-Protocol`
        // https://github.com/tootsuite/mastodon/pull/10818
        return (((_a = this.props.streamingApiUrl) === null || _a === void 0 ? void 0 : _a.startsWith('wss:')) &&
            semver.gte(this.props.version, new semver.SemVer('2.8.4', { loose: true })));
    }
}

class BaseHttp {
    get(path, data, init = {}) {
        return this.request({
            path,
            searchParams: data,
            requestInit: Object.assign({ method: 'GET' }, init),
        }).then((response) => response.data);
    }
    post(path, data, init = {}) {
        return this.request({
            path,
            body: data,
            requestInit: Object.assign({ method: 'POST' }, init),
        }).then((response) => response.data);
    }
    delete(path, data, init = {}) {
        return this.request({
            path,
            body: data,
            requestInit: Object.assign({ method: 'DELETE' }, init),
        }).then((response) => response.data);
    }
    put(path, data, init = {}) {
        return this.request({
            path,
            body: data,
            requestInit: Object.assign({ method: 'PUT' }, init),
        }).then((response) => response.data);
    }
    patch(path, data, init = {}) {
        return this.request({
            path,
            body: data,
            requestInit: Object.assign({ method: 'PATCH' }, init),
        }).then((response) => response.data);
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const getContentType = (headers) => {
    const contentType = headers.get('Content-Type');
    if (typeof contentType !== 'string') {
        return;
    }
    return contentType.replace(/\s*;.*$/, '');
};

class HttpNativeImpl extends BaseHttp {
    constructor(serializer, config, logger) {
        super();
        this.serializer = serializer;
        this.config = config;
        this.logger = logger;
    }
    request(params) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            const [request, timeout] = this.createRequest(params);
            try {
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(`↑ ${request.method} ${request.url}`);
                (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug('\tbody', request.body);
                const response = yield ponyfills.fetch(request);
                timeout.clear();
                if (!response.ok) {
                    throw response;
                }
                const text = yield response.text();
                const contentType = getContentType(response.headers);
                if (contentType == undefined) {
                    throw new MastoUnexpectedError('Content-Type is not defined');
                }
                const data = this.serializer.deserialize(contentType, text);
                (_c = this.logger) === null || _c === void 0 ? void 0 : _c.info(`↓ ${request.method} ${request.url}`);
                (_d = this.logger) === null || _d === void 0 ? void 0 : _d.debug('\tbody', text);
                return {
                    headers: response.headers,
                    data,
                };
            }
            catch (error) {
                (_e = this.logger) === null || _e === void 0 ? void 0 : _e.debug(`HTTP failed`, error);
                throw yield this.createError(error);
            }
        });
    }
    createRequest(params) {
        var _a;
        const { path, searchParams, requestInit } = params;
        const url = this.config.resolveHttpPath(path, searchParams);
        const headers = this.config.createHeader(requestInit === null || requestInit === void 0 ? void 0 : requestInit.headers);
        const [abortSignal, timeout] = this.config.createAbortSignal(requestInit === null || requestInit === void 0 ? void 0 : requestInit.signal);
        const body = this.serializer.serialize((_a = getContentType(headers)) !== null && _a !== void 0 ? _a : 'application/json', params.body);
        if (body instanceof ponyfills.FormData) {
            // As multipart form data should contain an arbitrary boundary,
            // leave Content-Type header undefined, so that fetch() API
            // automatically configure Content-Type with an appropriate boundary.
            headers.delete('Content-Type');
        }
        if (body == undefined && getContentType(headers) == 'application/json') {
            // Since an empty string is not a valid JSON,
            // if the body is empty and the content type is set to JSON,
            // remove 'content-type:application/json' from headers
            headers.delete('Content-Type');
        }
        const request = new ponyfills.Request(url, Object.assign(Object.assign({}, requestInit), { headers,
            body, signal: abortSignal }));
        return [request, timeout];
    }
    createError(error) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (error instanceof ponyfills.Response) {
                const data = this.serializer.deserialize((_a = getContentType(error.headers)) !== null && _a !== void 0 ? _a : 'application/json', yield error.text());
                return createHttpError({
                    cause: error,
                    statusCode: error.status,
                    message: data === null || data === void 0 ? void 0 : data.error,
                    details: data === null || data === void 0 ? void 0 : data.errorDescription,
                    description: data === null || data === void 0 ? void 0 : data.details,
                    limit: error.headers.get('X-RateLimit-Limit'),
                    remaining: error.headers.get('X-RateLimit-Remaining'),
                    reset: error.headers.get('X-RateLimit-Reset'),
                });
            }
            // TODO: Use abort reason
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (error != undefined && error.name === 'AbortError') {
                return new MastoTimeoutError(`Request timed out`, { cause: error });
            }
            return error;
        });
    }
}

var index$4 = /*#__PURE__*/Object.freeze({
  __proto__: null
});

/**
 * Decorator that verifies the version of the Mastodon instance
 * @param parameters Optional params
 */
const version = (params) => (_target, name, descriptor) => {
    const origin = descriptor.value;
    if (!origin) {
        throw new MastoUnexpectedError('version can only apply to a method of a class');
    }
    descriptor.value = function (...args) {
        const since = params.since && new semver.SemVer(params.since, { loose: true });
        const until = params.until && new semver.SemVer(params.until, { loose: true });
        const result = this.config.satisfiesVersion(since, until);
        switch (result.compat) {
            case 'unimplemented': {
                throw new MastoVersionError(`${String(this.constructor.name)}.${String(name)}` +
                    ` is not available with the current Mastodon version ` +
                    result.version +
                    ` It requires greater than or equal to version ${since}.`);
            }
            case 'removed': {
                throw new MastoVersionError(`${String(this.constructor.name)}.${String(name)}` +
                    ` is not available with the current Mastodon version` +
                    result.version +
                    ` It was removed on version ${until}.`);
            }
            case 'compatible': {
                return origin.apply(this, args);
            }
        }
    };
};

class Paginator {
    constructor(http, nextPath, nextParams) {
        this.http = http;
        this.nextPath = nextPath;
        this.nextParams = nextParams;
        this.pluckNext = (link) => {
            var _a;
            if (link == undefined) {
                return undefined;
            }
            const path = (_a = link
                .match(/<(.+?)>; rel="next"/)) === null || _a === void 0 ? void 0 : _a[1].replace(/^https?:\/\/[^/]+/, '');
            return path;
        };
    }
    next() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.nextPath == undefined) {
                return { done: true, value: undefined };
            }
            const response = yield this.http.request({
                requestInit: { method: 'GET' },
                path: this.nextPath,
                searchParams: this.nextParams,
            });
            const next = (_a = this.pluckNext(response.headers.get('link'))) === null || _a === void 0 ? void 0 : _a.split('?');
            this.nextPath = next === null || next === void 0 ? void 0 : next[0];
            this.nextParams = qs.parse((_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : '');
            return {
                done: false,
                value: response.data,
            };
        });
    }
    return(value) {
        return __awaiter(this, void 0, void 0, function* () {
            this.clear();
            return {
                done: true,
                value: yield value,
            };
        });
    }
    throw(e) {
        return __awaiter(this, void 0, void 0, function* () {
            this.clear();
            throw e;
        });
    }
    then(onfulfilled = Promise.resolve, onrejected = Promise.reject) {
        // we assume the first item won't be undefined
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.next().then((value) => onfulfilled(value.value), onrejected);
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    clear() {
        this.nextPath = undefined;
        this.nextParams = undefined;
    }
    clone() {
        return new Paginator(this.http, this.nextPath, this.nextParams);
    }
}

// implements Repository<Account, CreateAccountParams>
let AccountRepository$1 = class AccountRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View information about a profile.
     * @param id The id of the account in the database
     * @return Account
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    fetch(id) {
        return this.http.get(`/api/v1/accounts/${id}`);
    }
    /**
     * Creates a user and account records. Returns an account access token
     * for the app that initiated the request. The app should save this token for later,
     * and should wait for the user to confirm their account by clicking a link in their email inbox.
     * @param params Parameters
     * @return Token
     * @see https://docs.joinmastodon.org/methods/accounts/#create
     */
    create(params) {
        return this.http.post(`/api/v1/accounts`, params, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
    }
    /**
     * Test to make sure that the user token works.
     * @return the user's own Account with Source
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    verifyCredentials() {
        return this.http.get('/api/v1/accounts/verify_credentials');
    }
    /**
     *  Update the user's display and preferences.
     * @param params Parameters
     * @return the user's own Account with Source
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    updateCredentials(params) {
        return this.http.patch('/api/v1/accounts/update_credentials', params, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
    }
    /**
     * Accounts which follow the given account, if network is not hidden by the account owner.
     * @param id The id of the account in the database
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    listFollowers(id, params = {}) {
        return new Paginator(this.http, `/api/v1/accounts/${id}/followers`, params);
    }
    /**
     * Accounts which the given account is following, if network is not hidden by the account owner.
     * @param id The id of the account in the database
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    listFollowing(id, params = {}) {
        return new Paginator(this.http, `/api/v1/accounts/${id}/following`, params);
    }
    /**
     * Statuses posted to the given account.
     * @param id The id of the account in the database
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    listStatuses(id, params = {}) {
        return new Paginator(this.http, `/api/v1/accounts/${id}/statuses`, params);
    }
    /**
     * Follow the given account.
     * @param id The id of the account in the database
     * @param params Parameters
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    follow(id, params) {
        return this.http.post(`/api/v1/accounts/${id}/follow`, params);
    }
    /**
     * Unfollow the given account
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    unfollow(id, params) {
        return this.http.post(`/api/v1/accounts/${id}/unfollow`, params);
    }
    /**
     * Find out whether a given account is followed, blocked, muted, etc.
     * @param id Array of account IDs to check
     * @return Array of Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    fetchRelationships(id) {
        return this.http.get('/api/v1/accounts/relationships', {
            id,
        });
    }
    /**
     * Search for matching accounts by username or display name.
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    search(params) {
        return new Paginator(this.http, `/api/v1/accounts/search`, params);
    }
    /**
     * Block the given account. Clients should filter statuses from this account if received (e.g. due to a boost in the Home timeline)
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    block(id) {
        return this.http.post(`/api/v1/accounts/${id}/block`);
    }
    /**
     * Unblock the given account.
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    unblock(id) {
        return this.http.post(`/api/v1/accounts/${id}/unblock`);
    }
    /**
     * Add the given account to the user's featured profiles. (Featured profiles are currently shown on the user's own public profile.)
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts#pin
     */
    pin(id) {
        return this.http.post(`/api/v1/accounts/${id}/pin`);
    }
    /**
     * Remove the given account from the user's featured profiles.
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    unpin(id) {
        return this.http.post(`/api/v1/accounts/${id}/unpin`);
    }
    /**
     * Fetch the list with the given ID. Used for verifying the title of a list.
     * @param id ID of the list in the database
     * @return Array of List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    listLists(id) {
        return new Paginator(this.http, `/api/v1/accounts/${id}/lists`);
    }
    /**
     * Mute the given account. Clients should filter statuses and notifications from this account, if received (e.g. due to a boost in the Home timeline).
     * @param id The id of the account in the database
     * @param params Parameter
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    mute(id, params) {
        return this.http.post(`/api/v1/accounts/${id}/mute`, params);
    }
    /**
     * Unmute the given account.
     * @param id The id of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    unmute(id) {
        return this.http.post(`/api/v1/accounts/${id}/unmute`);
    }
    /**
     * Add personal note to the account
     * @param id ID of the account
     * @param param Parameters
     * @return Relationship
     */
    createNote(id, params) {
        return this.http.post(`/api/v1/accounts/${id}/note`, params);
    }
    /**
     * Get featured tag of the account
     * @param id ID of the account
     * @return FeaturedTags
     */
    listFeaturedTags(id) {
        return new Paginator(this.http, `/api/v1/accounts/${id}/featured_tags`);
    }
    /**
     * Identity proofs
     * @param id The id of the account in the database
     * @return Array of IdentityProof
     * @see https://github.com/tootsuite/mastodon/pull/10297
     */
    listIdentityProofs(id) {
        return new Paginator(this.http, `/api/v1/accounts/${id}/identity_proofs`);
    }
    /**
     * This method allows to quickly convert a username of a known account to an ID that can be used with the REST API, or to check if a username is available for sign-up
     * @param params Parameters
     * @return Account
     */
    lookup(params) {
        return this.http.get('/api/v1/accounts/lookup', params);
    }
    /**
     * Obtain a list of all accounts that follow a given account, filtered for accounts you follow.
     * @returns Array of FamiliarFollowers
     */
    fetchFamiliarFollowers(id) {
        return this.http.get(`/api/v1/accounts/familiar_followers`, { id });
    }
    /**
     * @param id ID of the account
     * @returns N/A
     */
    removeFromFollowers(id) {
        return this.http.post(`/api/v1/accounts/${id}/remove_from_followers`);
    }
};
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "fetch", null);
__decorate([
    version({ since: '2.7.0' })
], AccountRepository$1.prototype, "create", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "verifyCredentials", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "updateCredentials", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "listFollowers", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "listFollowing", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "listStatuses", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "follow", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "unfollow", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "fetchRelationships", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "search", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "block", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "unblock", null);
__decorate([
    version({ since: '2.5.0' })
], AccountRepository$1.prototype, "pin", null);
__decorate([
    version({ since: '2.5.0' })
], AccountRepository$1.prototype, "unpin", null);
__decorate([
    version({ since: '2.1.0' })
], AccountRepository$1.prototype, "listLists", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "mute", null);
__decorate([
    version({ since: '0.0.0' })
], AccountRepository$1.prototype, "unmute", null);
__decorate([
    version({ since: '3.2.0' })
], AccountRepository$1.prototype, "createNote", null);
__decorate([
    version({ since: '3.3.0' })
], AccountRepository$1.prototype, "listFeaturedTags", null);
__decorate([
    version({ since: '2.8.0' })
], AccountRepository$1.prototype, "listIdentityProofs", null);
__decorate([
    version({ since: '3.4.0' })
], AccountRepository$1.prototype, "lookup", null);
__decorate([
    version({ since: '3.5.0' })
], AccountRepository$1.prototype, "fetchFamiliarFollowers", null);
__decorate([
    version({ since: '3.5.0' })
], AccountRepository$1.prototype, "removeFromFollowers", null);

/**
 * Decorator that verifies the version of the Mastodon instance
 * @param parameters Optional params
 */
const deprecated = (message) => (_target, name, descriptor) => {
    const origin = descriptor.value;
    if (origin == undefined) {
        throw new MastoUnexpectedError('deprecated can only apply to a method of a class');
    }
    descriptor.value = function (...args) {
        var _a, _b;
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.shouldWarnDeprecated()) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn(`#${name.toString()} is deprecated. ${message}`);
        }
        return origin.apply(this, args);
    };
};

class StreamRepository {
    constructor(ws, config, logger) {
        this.ws = ws;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Starting home timeline and notification streaming
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamUser() {
        return this.ws.stream('/api/v1/streaming', {
            stream: 'user',
        });
    }
    /**
     * Starting federated timeline streaming
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamPublicTimeline() {
        return this.ws.stream('/api/v1/streaming', {
            stream: 'public',
        });
    }
    /**
     * Starting local timeline streaming
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamCommunityTimeline() {
        return this.ws.stream('/api/v1/streaming', {
            stream: 'public:local',
        });
    }
    /**
     * Stream remote public timeline
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamRemotePublicTimeline() {
        return this.ws.stream('/api/v1/streaming', {
            stream: 'public:remote',
        });
    }
    /**
     * Starting tag timeline streaming
     * @param id ID of the tag
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamTagTimeline(id) {
        return this.ws.stream('/api/v1/streaming', {
            stream: 'hashtag',
            tag: id,
        });
    }
    /**
     * Starting local tag timeline streaming
     * @param id ID of the tag
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamLocalTagTimeline(id) {
        return this.ws.stream('/api/v1/streaming', {
            stream: 'hashtag:local',
            tag: id,
        });
    }
    /**
     * Starting list timeline streaming
     * @param id ID of the list
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamListTimeline(id) {
        return this.ws.stream('/api/v1/streaming', {
            stream: 'list',
            list: id,
        });
    }
    /**
     * Starting direct timeline streaming
     * @return Instance of EventEmitter
     * @see https://docs.joinmastodon.org/methods/timelines/streaming/
     */
    streamDirectTimeline() {
        return this.ws.stream('/api/v1/streaming', {
            stream: 'direct',
        });
    }
}
__decorate([
    version({ since: '0.0.0' })
], StreamRepository.prototype, "streamUser", null);
__decorate([
    version({ since: '0.0.0' })
], StreamRepository.prototype, "streamPublicTimeline", null);
__decorate([
    version({ since: '0.0.0' })
], StreamRepository.prototype, "streamCommunityTimeline", null);
__decorate([
    version({ since: '0.0.0' })
], StreamRepository.prototype, "streamRemotePublicTimeline", null);
__decorate([
    version({ since: '0.0.0' })
], StreamRepository.prototype, "streamTagTimeline", null);
__decorate([
    version({ since: '0.0.0' })
], StreamRepository.prototype, "streamLocalTagTimeline", null);
__decorate([
    version({ since: '0.0.0' })
], StreamRepository.prototype, "streamListTimeline", null);
__decorate([
    version({ since: '0.0.0' })
], StreamRepository.prototype, "streamDirectTimeline", null);

class AnnouncementRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Fetch announcements
     * @return Announcements
     * @see https://docs.joinmastodon.org/methods/announcements/
     */
    list() {
        return new Paginator(this.http, '/api/v1/announcements');
    }
    /**
     * Dismiss announcement
     * @param id ID of the announcement
     * @return Nothing
     * @see https://docs.joinmastodon.org/methods/announcements/
     */
    dismiss(id) {
        return this.http.post(`/api/v1/announcements/${id}/dismiss`);
    }
    /**
     * Add a reaction to an announcement
     * @param id ID of the announcement
     * @param name Emoji string
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/announcements/
     */
    addReaction(id, name) {
        return this.http.put(`/api/v1/announcements/${id}/reactions/${name}`);
    }
    /**
     * Remove a reaction from an announcement
     * @param id ID of the announcement
     * @param name Emoji string
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/announcements/
     */
    removeReaction(id, name) {
        return this.http.delete(`/api/v1/announcements/${id}/reactions/${name}`);
    }
}
__decorate([
    version({ since: '3.1.0' })
], AnnouncementRepository.prototype, "list", null);
__decorate([
    version({ since: '3.1.0' })
], AnnouncementRepository.prototype, "dismiss", null);
__decorate([
    version({ since: '3.1.0' })
], AnnouncementRepository.prototype, "addReaction", null);
__decorate([
    version({ since: '3.1.0' })
], AnnouncementRepository.prototype, "removeReaction", null);

class AppRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Create a new application to obtain OAuth2 credentials.
     * @param params Parameters
     * @return Returns App with `client_id` and `client_secret`
     * @see https://docs.joinmastodon.org/methods/apps/
     */
    create(params) {
        return this.http.post(`/api/v1/apps`, params);
    }
    /**
     * Confirm that the app's OAuth2 credentials work.
     * @return Application
     * @see https://docs.joinmastodon.org/methods/apps/
     */
    verifyCredentials() {
        return this.http.get(`/api/v1/apps/verify_credentials`);
    }
}
__decorate([
    version({ since: '0.0.0' })
], AppRepository.prototype, "create", null);
__decorate([
    version({ since: '2.0.0' })
], AppRepository.prototype, "verifyCredentials", null);

class BlockRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Blocked users
     * @param params Array of Account
     * @return Query parameter
     * @see https://docs.joinmastodon.org/methods/accounts/blocks/
     */
    list(params = {}) {
        return new Paginator(this.http, `/api/v1/blocks`, params);
    }
}
__decorate([
    version({ since: '0.0.0' })
], BlockRepository.prototype, "list", null);

class BookmarkRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Statuses the user has bookmarked.
     * @param params Parameters
     * @return Array of Statuses
     * @see https://docs.joinmastodon.org/methods/accounts/bookmarks/
     */
    list(params = {}) {
        return new Paginator(this.http, '/api/v1/bookmarks', params);
    }
}
__decorate([
    version({ since: '3.1.0' })
], BookmarkRepository.prototype, "list", null);

class ConversationRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Show conversation
     * @param params Parameters
     * @return Array of Conversation
     * @see https://docs.joinmastodon.org/methods/timelines/conversations/
     */
    list(params = {}) {
        return new Paginator(this.http, '/api/v1/conversations', params);
    }
    /**
     * Remove conversation
     * @param id ID of the conversation in the database
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/timelines/conversations/
     */
    remove(id) {
        return this.http.delete(`/api/v1/conversations/${id}`);
    }
    /**
     * Mark as read
     * @param id ID of the conversation in the database
     * @return Conversation
     * @see https://docs.joinmastodon.org/methods/timelines/conversations/
     */
    read(id) {
        return this.http.post(`/api/v1/conversations/${id}/read`);
    }
}
__decorate([
    version({ since: '2.6.0' })
], ConversationRepository.prototype, "list", null);
__decorate([
    version({ since: '2.6.0' })
], ConversationRepository.prototype, "remove", null);
__decorate([
    version({ since: '2.6.0' })
], ConversationRepository.prototype, "read", null);

class CustomEmojiRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Returns custom emojis that are available on the server.
     * @return Array of Emoji
     * @see https://docs.joinmastodon.org/methods/instance/custom_emojis/
     */
    list() {
        return new Paginator(this.http, `/api/v1/custom_emojis`);
    }
}
__decorate([
    version({ since: '2.0.0' })
], CustomEmojiRepository.prototype, "list", null);

class DirectoryRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * List accounts visible in the directory.
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/instance/directory/
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/directory', params);
    }
}
__decorate([
    version({ since: '3.0.0' })
], DirectoryRepository.prototype, "list", null);

let DomainBlockRepository$1 = class DomainBlockRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View domains the user has blocked.
     * @param params Parameters
     * @return Array of strings
     * @see https://docs.joinmastodon.org/methods/accounts/domain_blocks/
     */
    list(params) {
        return new Paginator(this.http, `/api/v1/domain_blocks`, params);
    }
    /**
     * Block a domain to:
     * - hide all public posts from it
     * - hide all notifications from it
     * - remove all followers from it
     * - prevent following new users from it (but does not remove existing follows)
     * @param domain Domain to block.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/domain_blocks/
     */
    block(domain) {
        return this.http.post(`/api/v1/domain_blocks`, {
            domain,
        });
    }
    /**
     * Remove a domain block, if it exists in the user's array of blocked domains.
     * @param domain Domain to unblock
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/domain_blocks/
     */
    unblock(domain) {
        return this.http.delete(`/api/v1/domain_blocks`, {
            domain,
        });
    }
};
__decorate([
    version({ since: '1.4.0' })
], DomainBlockRepository$1.prototype, "list", null);
__decorate([
    version({ since: '1.4.0' })
], DomainBlockRepository$1.prototype, "block", null);
__decorate([
    version({ since: '1.4.0' })
], DomainBlockRepository$1.prototype, "unblock", null);

class EndorsementRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Accounts that the user is currently featuring on their profile.
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/endorsements/
     */
    list(params) {
        return new Paginator(this.http, `/api/v1/endorsements`, params);
    }
}
__decorate([
    version({ since: '2.5.0' })
], EndorsementRepository.prototype, "list", null);

class FavouriteRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Statuses the user has favourited.
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/accounts/favourites/
     */
    list(params) {
        return new Paginator(this.http, `/api/v1/favourites`, params);
    }
}
__decorate([
    version({ since: '0.0.0' })
], FavouriteRepository.prototype, "list", null);

class FeaturedTagRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View your featured tags
     * @return Array of FeaturedTag
     * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
     * @done
     */
    list() {
        return new Paginator(this.http, '/api/v1/featured_tags');
    }
    /**
     * Feature a tag
     * @param params Parameters
     * @return FeaturedTag
     * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
     */
    create(params) {
        return this.http.post('/api/v1/featured_tags', params, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
    }
    /**
     * Shows your 10 most-used tags, with usage history for the past week.
     * @return Array of Tag with History
     * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
     */
    listSuggestions() {
        return new Paginator(this.http, '/api/v1/featured_tags/suggestions');
    }
    /**
     * Un-feature a tag
     * @param id The id of the FeaturedTag to be un-featured
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
     */
    remove(id) {
        return this.http.delete(`/api/v1/featured_tags/${id}`);
    }
}
__decorate([
    version({ since: '3.0.0' })
], FeaturedTagRepository.prototype, "list", null);
__decorate([
    version({ since: '3.0.0' })
], FeaturedTagRepository.prototype, "create", null);
__decorate([
    version({ since: '3.0.0' })
], FeaturedTagRepository.prototype, "listSuggestions", null);
__decorate([
    version({ since: '3.0.0' })
], FeaturedTagRepository.prototype, "remove", null);

let FilterRepository$1 = class FilterRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View all filters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    list() {
        return new Paginator(this.http, `/api/v1/filters`);
    }
    /**
     * View a single filter
     * @param id ID of the filter
     * @return Returns Filter
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    fetch(id) {
        return this.http.get(`/api/v1/filters/${id}`);
    }
    /**
     * Create a filter
     * @param params Parameters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    create(params) {
        return this.http.post(`/api/v1/filters`, params);
    }
    /**
     * Update a filter
     * @param id ID of the filter in the database
     * @param params Parameters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    update(id, params) {
        return this.http.put(`/api/v1/filters/${id}`, params);
    }
    /**
     * Remove a filter
     * @param id ID of the filter in the database
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    remove(id) {
        return this.http.delete(`/api/v1/filters/${id}`);
    }
};
__decorate([
    version({ since: '2.4.3' })
], FilterRepository$1.prototype, "list", null);
__decorate([
    version({ since: '2.4.3' })
], FilterRepository$1.prototype, "fetch", null);
__decorate([
    version({ since: '2.4.3' })
], FilterRepository$1.prototype, "create", null);
__decorate([
    version({ since: '2.4.3' })
], FilterRepository$1.prototype, "update", null);
__decorate([
    version({ since: '2.4.3' })
], FilterRepository$1.prototype, "remove", null);

class FollowRequestRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Pending Follows
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/follow_requests/
     */
    list(params) {
        return new Paginator(this.http, `/api/v1/follow_requests`, params);
    }
    /**
     * Accept Follow
     * @param id ID of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/follow_requests/
     */
    authorize(id) {
        return this.http.post(`/api/v1/follow_requests/${id}/authorize`);
    }
    /**
     * Reject Follow
     * @param id ID of the account in the database
     * @return Relationship
     * @see https://docs.joinmastodon.org/methods/accounts/follow_requests/
     */
    reject(id) {
        return this.http.post(`/api/v1/follow_requests/${id}/reject`);
    }
}
__decorate([
    version({ since: '0.0.0' })
], FollowRequestRepository.prototype, "list", null);
__decorate([
    version({ since: '0.0.0' })
], FollowRequestRepository.prototype, "authorize", null);
__decorate([
    version({ since: '0.0.0' })
], FollowRequestRepository.prototype, "reject", null);

let InstanceRepository$1 = class InstanceRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Information about the server.
     * @return Instance
     * @see https://docs.joinmastodon.org/methods/instance/
     */
    fetch() {
        return this.http.get('/api/v1/instance');
    }
    /**
     * Domains that this instance is aware of.
     * @return Array of Activity
     * @see https://docs.joinmastodon.org/methods/instance/
     */
    listPeers() {
        return new Paginator(this.http, '/api/v1/instance/peers');
    }
    /**
     * Instance activity over the last 3 months, binned weekly.
     * @return Array of Activity
     * @see https://docs.joinmastodon.org/methods/instance/
     */
    listActivities() {
        return new Paginator(this.http, '/api/v1/instance/activity');
    }
};
__decorate([
    version({ since: '1.0.0' })
], InstanceRepository$1.prototype, "fetch", null);
__decorate([
    version({ since: '2.1.2' })
], InstanceRepository$1.prototype, "listPeers", null);
__decorate([
    version({ since: '2.1.2' })
], InstanceRepository$1.prototype, "listActivities", null);

class ListRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Fetch the list with the given ID. Used for verifying the title of a list.
     * @param id ID of the list in the database
     * @return List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    fetch(id) {
        return this.http.get(`/api/v1/lists/${id}`);
    }
    /**
     * Fetch all lists that the user owns.
     * @return Array of List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    list() {
        return new Paginator(this.http, '/api/v1/lists');
    }
    /**
     * Create a new list.
     * @param params Parameters
     * @return List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    create(params) {
        return this.http.post('/api/v1/lists', params);
    }
    /**
     * Change the title of a list.
     * @param id ID of the list in the database
     * @param params Parameters
     * @return List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    update(id, params) {
        return this.http.put(`/api/v1/lists/${id}`, params);
    }
    /**
     * Delete a list
     * @param id ID of the list in the database
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    remove(id) {
        return this.http.delete(`/api/v1/lists/${id}`);
    }
    /**
     * View accounts in list
     * @param id ID of the list in the database
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/timelines/lists#accounts
     */
    listAccounts(id, params) {
        return new Paginator(this.http, `/api/v1/lists/${id}/accounts`, params);
    }
    /**
     * Add accounts to the given list. Note that the user must be following these accounts.
     * @param id ID of the list in the database
     * @param params Parameters
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/timelines/lists#accounts-add
     */
    addAccount(id, params) {
        return this.http.post(`/api/v1/lists/${id}/accounts`, params);
    }
    /**
     * Remove accounts from the given list.
     * @param id ID of the list in the database
     * @param params Parameters
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/timelines/lists#accounts-remove
     */
    removeAccount(id, params) {
        return this.http.delete(`/api/v1/lists/${id}/accounts`, params);
    }
}
__decorate([
    version({ since: '2.1.0' })
], ListRepository.prototype, "fetch", null);
__decorate([
    version({ since: '2.1.0' })
], ListRepository.prototype, "list", null);
__decorate([
    version({ since: '2.1.0' })
], ListRepository.prototype, "create", null);
__decorate([
    version({ since: '2.1.0' })
], ListRepository.prototype, "update", null);
__decorate([
    version({ since: '2.1.0' })
], ListRepository.prototype, "remove", null);
__decorate([
    version({ since: '2.1.0' })
], ListRepository.prototype, "listAccounts", null);
__decorate([
    version({ since: '2.1.0' })
], ListRepository.prototype, "addAccount", null);
__decorate([
    version({ since: '2.1.0' })
], ListRepository.prototype, "removeAccount", null);

class MarkerRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Get saved timeline position
     * @param params Parameters
     * @return Markers
     * @see https://docs.joinmastodon.org/methods/timelines/markers/
     */
    fetch(params) {
        return this.http.get('/api/v1/markers', params);
    }
    /**
     * Save position in timeline
     * @param params Parameters
     * @return Markers
     * @see https://github.com/tootsuite/mastodon/pull/11762
     */
    create(params) {
        return this.http.post('/api/v1/markers', params);
    }
}
__decorate([
    version({ since: '3.0.0' })
], MarkerRepository.prototype, "fetch", null);
__decorate([
    version({ since: '3.0.0' })
], MarkerRepository.prototype, "create", null);

let MediaAttachmentRepository$1 = class MediaAttachmentRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Creates an attachment to be used with a new status.
     * @param params Parameters
     * @return Attachment
     * @see https://docs.joinmastodon.org/methods/statuses/media/
     */
    /* istanbul ignore next */
    create(params) {
        return this.http.post(`/api/v1/media`, params, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
    }
    /**
     * Fetches an attachment to be used with a new status.
     * @param id ID of the attachment
     * @see https://github.com/tootsuite/mastodon/pull/13210
     */
    fetch(id) {
        return this.http.get(`/api/v1/media/${id}`);
    }
    /**
     * Update an Attachment, before it is attached to a status and posted.
     * @param id The id of the Attachment entity to be updated
     * @param params Parameters
     * @return Attachment
     * @see https://docs.joinmastodon.org/methods/statuses/media/
     */
    update(id, params) {
        return this.http.put(`/api/v1/media/${id}`, params, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
    }
};
__decorate([
    deprecated('Use MastoClient.v2.media.create instead'),
    version({ since: '0.0.0', until: '3.1.3' })
    /* istanbul ignore next */
], MediaAttachmentRepository$1.prototype, "create", null);
__decorate([
    version({ since: '3.1.3' })
], MediaAttachmentRepository$1.prototype, "fetch", null);
__decorate([
    version({ since: '0.0.0' })
], MediaAttachmentRepository$1.prototype, "update", null);

class MuteRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Accounts the user has muted.
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/mutes/
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/mutes', params);
    }
}
__decorate([
    version({ since: '0.0.0' })
], MuteRepository.prototype, "list", null);

class NotificationRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Notifications concerning the user.
     * This API returns Link headers containing links to the next/previous page.
     * However, the links can also be constructed dynamically using query params and `id` values.
     * @param params Query parameter
     * @return Array of Notification
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/notifications', params);
    }
    /**
     * View information about a notification with a given ID.
     * @param id ID of the notification in the database.
     * @return Notification
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    fetch(id) {
        return this.http.get(`/api/v1/notifications/${id}`);
    }
    /**
     * Clear all notifications from the server.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    clear() {
        return this.http.post('/api/v1/notifications/clear');
    }
    /**
     * Clear a single notification from the server.
     * @param id ID of the notification to be cleared
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    dismiss(id) {
        return this.http.post(`/api/v1/notifications/${id}/dismiss`);
    }
}
__decorate([
    version({ since: '0.0.0' })
], NotificationRepository.prototype, "list", null);
__decorate([
    version({ since: '0.0.0' })
], NotificationRepository.prototype, "fetch", null);
__decorate([
    version({ since: '0.0.0' })
], NotificationRepository.prototype, "clear", null);
__decorate([
    version({ since: '2.6.0' })
], NotificationRepository.prototype, "dismiss", null);

class PollRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View a poll
     * @param id ID of the poll in the database
     * @return Poll
     * @see https://docs.joinmastodon.org/methods/statuses/polls#get
     */
    fetch(id) {
        return this.http.get(`/api/v1/polls/${id}`);
    }
    /**
     * Vote on a poll
     * @param id ID of the poll in the database
     * @param params Parameters
     * @return Poll
     * @see https://docs.joinmastodon.org/methods/statuses/polls#vote
     */
    vote(id, params) {
        return this.http.post(`/api/v1/polls/${id}/votes`, params);
    }
}
__decorate([
    version({ since: '2.8.0' })
], PollRepository.prototype, "fetch", null);
__decorate([
    version({ since: '2.8.0' })
], PollRepository.prototype, "vote", null);

class PreferenceRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Preferences defined by the user in their account settings.
     * @return Preferences by key and value
     * @see https://docs.joinmastodon.org/methods/accounts/preferences/
     */
    fetch() {
        return this.http.get('/api/v1/preferences');
    }
}
__decorate([
    version({ since: '2.8.0' })
], PreferenceRepository.prototype, "fetch", null);

class WebPushSubscriptionRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Add a Web Push API subscription to receive notifications.
     * Each access token can have one push subscription.
     * If you create a new subscription, the old subscription is deleted.
     * @param params Parameters
     * @return Returns Push Subscription
     * @see https://docs.joinmastodon.org/methods/notifications/push/
     */
    create(params) {
        return this.http.post('/api/v1/push/subscription', params);
    }
    /**
     * View the PushSubscription currently associated with this access token.
     * @return PushSubscription
     * @see https://docs.joinmastodon.org/methods/notifications/push/
     */
    fetch() {
        return this.http.get('/api/v1/push/subscription');
    }
    /**
     * Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead.
     * @param params Parameters
     * @return PushSubscription
     * @see https://docs.joinmastodon.org/methods/notifications/push/
     */
    update(params) {
        return this.http.put('/api/v1/push/subscription', params);
    }
    /**
     * Removes the current Web Push API subscription.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/notifications/push/
     */
    remove() {
        return this.http.delete('/api/v1/push/subscription');
    }
}
__decorate([
    version({ since: '2.4.0' })
], WebPushSubscriptionRepository.prototype, "create", null);
__decorate([
    version({ since: '2.4.0' })
], WebPushSubscriptionRepository.prototype, "fetch", null);
__decorate([
    version({ since: '2.4.0' })
], WebPushSubscriptionRepository.prototype, "update", null);
__decorate([
    version({ since: '2.4.0' })
], WebPushSubscriptionRepository.prototype, "remove", null);

let ReportRepository$1 = class ReportRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * File a report
     * @param params Parameters
     * @return Report
     * @see https://docs.joinmastodon.org/methods/accounts/reports/
     */
    create(params) {
        return this.http.post('/api/v1/reports', params);
    }
};
__decorate([
    version({ since: '1.1.0' })
], ReportRepository$1.prototype, "create", null);

class ScheduledStatusRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View scheduled statuses
     * @param params Parameters
     * @return Array of ScheduledStatus
     * @see https://docs.joinmastodon.org/methods/statuses/scheduled_statuses/
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/scheduled_statuses', params);
    }
    /**
     * View a single scheduled status
     * @param id ID of the scheduled status in the database.
     * @return ScheduledStatus
     * @see https://docs.joinmastodon.org/methods/statuses/scheduled_statuses/
     */
    fetch(id) {
        return this.http.get(`/api/v1/scheduled_statuses/${id}`);
    }
    /**
     * Update Scheduled status
     * @param id ID of the Status to be scheduled
     * @param params Parameters
     * @return ScheduledStatus
     * @see https://docs.joinmastodon.org/api/rest/scheduled-statuses/#put-api-v1-scheduled-statuses-id
     */
    update(id, params) {
        return this.http.put(`/api/v1/scheduled_statuses/${id}`, params);
    }
    /**
     * Cancel a scheduled status
     * @param id ID of the scheduled status in the database.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/statuses/scheduled_statuses/
     */
    remove(id) {
        return this.http.delete(`/api/v1/scheduled_statuses/${id}`);
    }
}
__decorate([
    version({ since: '2.7.0' })
], ScheduledStatusRepository.prototype, "list", null);
__decorate([
    version({ since: '2.7.0' })
], ScheduledStatusRepository.prototype, "fetch", null);
__decorate([
    version({ since: '2.7.0' })
], ScheduledStatusRepository.prototype, "update", null);
__decorate([
    version({ since: '2.7.0' })
], ScheduledStatusRepository.prototype, "remove", null);

class StatusRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View information about a status.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    fetch(id) {
        return this.http.get(`/api/v1/statuses/${id}`);
    }
    create(params, extra = {}) {
        if (extra.idempotencyKey) {
            return this.http.post('/api/v1/statuses', params, {
                headers: { 'Idempotency-Key': extra.idempotencyKey },
            });
        }
        return this.http.post('/api/v1/statuses', params);
    }
    /**
     * Update a status
     * @param params Parameters
     * @return Status. When scheduled_at is present, ScheduledStatus is returned instead.
     * @see https://docs.joinmastodon.org/api/rest/statuses/#post-api-v1-statuses
     */
    update(id, params) {
        return this.http.put(`/api/v1/statuses/${id}`, params);
    }
    /**
     * Delete one of your own statuses.
     * @param id Local ID of a status in the database. Must be owned by authenticated account.
     * @return Status with source text and `media_attachments` or `poll`
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    remove(id) {
        return this.http.delete(`/api/v1/statuses/${id}`);
    }
    /**
     * View statuses above and below this status in the thread.
     * @param id Local ID of a status in the database.
     * @return Context
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    fetchContext(id) {
        return this.http.get(`/api/v1/statuses/${id}/context`);
    }
    /**
     * Preview card
     * @deprecated Use `card` attribute of status instead
     * @param id ID of the status in the database
     * @return Card
     * @see https://docs.joinmastodon.org/api/rest/statuses/#get-api-v1-statuses-id-card
     */
    /* istanbul ignore next */
    fetchCard(id) {
        return this.http.get(`/api/v1/statuses/${id}/card`);
    }
    /**
     * Add a status to your favourites list.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    favourite(id) {
        return this.http.post(`/api/v1/statuses/${id}/favourite`);
    }
    /**
     * Remove a status from your favourites list.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    unfavourite(id) {
        return this.http.post(`/api/v1/statuses/${id}/unfavourite`);
    }
    /**
     * Do not receive notifications for the thread that this status is part of. Must be a thread in which you are a participant.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    mute(id) {
        return this.http.post(`/api/v1/statuses/${id}/mute`);
    }
    /**
     * Start receiving notifications again for the thread that this status is part of.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    unmute(id) {
        return this.http.post(`/api/v1/statuses/${id}/unmute`);
    }
    /**
     * View who boosted a given status.
     * @param id Local ID of a status in the database.
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    listRebloggedBy(id) {
        return new Paginator(this.http, `/api/v1/statuses/${id}/reblogged_by`);
    }
    /**
     * View who favourited a given status.
     * @param id Local ID of a status in the database.
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    listFavouritedBy(id) {
        return new Paginator(this.http, `/api/v1/statuses/${id}/favourited_by`);
    }
    /**
     * Re-share a status.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/api/rest/statuses/#post-api-v1-statuses-id-reblog
     */
    reblog(id, params) {
        return this.http.post(`/api/v1/statuses/${id}/reblog`, params);
    }
    /**
     * Undo a re-share of a status.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    unreblog(id) {
        return this.http.post(`/api/v1/statuses/${id}/unreblog`);
    }
    /**
     * Feature one of your own public statuses at the top of your profile.
     * @param id Local ID of a status in the database. The status should be public and authored by the authorized account.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    pin(id) {
        return this.http.post(`/api/v1/statuses/${id}/pin`);
    }
    /**
     * Un-feature a status from the top of your profile.
     * @param id Local ID of a status in the database.
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    unpin(id) {
        return this.http.post(`/api/v1/statuses/${id}/unpin`);
    }
    /**
     * Privately bookmark a status.
     * @param id ID of the status in the database
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    bookmark(id) {
        return this.http.post(`/api/v1/statuses/${id}/bookmark`);
    }
    /**
     * Remove a status from your private bookmarks.
     * @param id ID of the status in the database
     * @return Status
     * @see https://docs.joinmastodon.org/methods/statuses/
     */
    unbookmark(id) {
        return this.http.post(`/api/v1/statuses/${id}/unbookmark`);
    }
    /**
     * Get all known versions of a status, including the initial and current states.
     * @param id The local id of the status in the database
     * @returns StatusEdit
     * @see https://docs.joinmastodon.org/methods/statuses/#history
     */
    listHistory(id) {
        return new Paginator(this.http, `/api/v1/statuses/${id}/history`);
    }
    /**
     * Obtain the source properties for a status so that it can be edited.
     * @param id The local ID of the Status in the database
     * @returns StatusSource
     * @see https://docs.joinmastodon.org/methods/statuses/#source
     */
    fetchSource(id) {
        return this.http.get(`/api/v1/statuses/${id}/source`);
    }
    /**
     * Translate the status content into some language.
     * @param id String. The ID of the Status in the database.
     * @param params Form data parameters
     * @returns Translation
     */
    translate(id, params) {
        return this.http.post(`/api/v1/statuses/${id}/translate`, params, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
    }
}
__decorate([
    version({ since: '0.0.0' })
], StatusRepository.prototype, "fetch", null);
__decorate([
    version({ since: '0.0.0' })
], StatusRepository.prototype, "create", null);
__decorate([
    version({ since: '3.5.0' })
], StatusRepository.prototype, "update", null);
__decorate([
    version({ since: '0.0.0' })
], StatusRepository.prototype, "remove", null);
__decorate([
    version({ since: '0.0.0' })
], StatusRepository.prototype, "fetchContext", null);
__decorate([
    deprecated('Use `card` attribute of status instead'),
    version({ since: '0.0.0', until: '2.9.3' })
    /* istanbul ignore next */
], StatusRepository.prototype, "fetchCard", null);
__decorate([
    version({ since: '0.0.0' })
], StatusRepository.prototype, "favourite", null);
__decorate([
    version({ since: '0.0.0' })
], StatusRepository.prototype, "unfavourite", null);
__decorate([
    version({ since: '1.4.2' })
], StatusRepository.prototype, "mute", null);
__decorate([
    version({ since: '1.4.2' })
], StatusRepository.prototype, "unmute", null);
__decorate([
    version({ since: '0.0.0' })
], StatusRepository.prototype, "listRebloggedBy", null);
__decorate([
    version({ since: '0.0.0' })
], StatusRepository.prototype, "listFavouritedBy", null);
__decorate([
    version({ since: '0.0.0' })
], StatusRepository.prototype, "reblog", null);
__decorate([
    version({ since: '0.0.0' })
], StatusRepository.prototype, "unreblog", null);
__decorate([
    version({ since: '1.6.0' })
], StatusRepository.prototype, "pin", null);
__decorate([
    version({ since: '1.6.0' })
], StatusRepository.prototype, "unpin", null);
__decorate([
    version({ since: '3.1.0' })
], StatusRepository.prototype, "bookmark", null);
__decorate([
    version({ since: '3.1.0' })
], StatusRepository.prototype, "unbookmark", null);
__decorate([
    version({ since: '3.5.0' })
], StatusRepository.prototype, "listHistory", null);
__decorate([
    version({ since: '3.5.0' })
], StatusRepository.prototype, "fetchSource", null);
__decorate([
    version({ since: '4.0.0' })
], StatusRepository.prototype, "translate", null);

let SuggestionRepository$1 = class SuggestionRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Accounts the user has had past positive interactions with, but is not yet following.
     * @param params
     * @returns
     * @see https://docs.joinmastodon.org/methods/suggestions/#v1
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/suggestions', params);
    }
    /**
     * Remove an account from follow suggestions.
     * @param id id of the account in the database to be removed from suggestions
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/suggestions/
     */
    /* istanbul ignore next */
    remove(id) {
        return this.http.delete(`/api/v1/suggestions/${id}`);
    }
};
__decorate([
    deprecated('Use MastoClient.v2.suggestions.list instead'),
    version({ since: '2.4.3' })
], SuggestionRepository$1.prototype, "list", null);
__decorate([
    version({ since: '2.4.3' })
    /* istanbul ignore next */
], SuggestionRepository$1.prototype, "remove", null);

class TimelineRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View statuses from followed users.
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/timelines/
     */
    listHome(params) {
        return new Paginator(this.http, '/api/v1/timelines/home', params);
    }
    /**
     * Public timeline
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/timelines/
     */
    listPublic(params) {
        return new Paginator(this.http, '/api/v1/timelines/public', params);
    }
    /**
     * View public statuses containing the given hashtag.
     * @param hashtag Content of a #hashtag, not including # symbol.
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/timelines/
     */
    listHashtag(hashtag, params) {
        return new Paginator(this.http, `/api/v1/timelines/tag/${hashtag}`, params);
    }
    /**
     * View statuses in the given list timeline.
     * @param id Local ID of the list in the database.
     * @param params Query parameter
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/timelines/
     */
    listList(id, params) {
        return new Paginator(this.http, `/api/v1/timelines/list/${id}`, params);
    }
    /**
     * View statuses with a “direct” privacy, from your account or in your notifications.
     * @deprecated Use conversations API instead
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/timelines/
     */
    /* istanbul ignore next */
    listDirect(params) {
        return new Paginator(this.http, '/api/v1/timelines/direct', params);
    }
}
__decorate([
    version({ since: '0.0.0' })
], TimelineRepository.prototype, "listHome", null);
__decorate([
    version({ since: '0.0.0' })
], TimelineRepository.prototype, "listPublic", null);
__decorate([
    version({ since: '0.0.0' })
], TimelineRepository.prototype, "listHashtag", null);
__decorate([
    version({ since: '2.1.0' })
], TimelineRepository.prototype, "listList", null);
__decorate([
    deprecated('Use conversations API instead'),
    version({ since: '0.0.0', until: '2.9.3' })
    /* istanbul ignore next */
], TimelineRepository.prototype, "listDirect", null);

let TrendRepository$1 = class TrendRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View trending statuses
     * @returns Array of Status
     * @see https://docs.joinmastodon.org/methods/trends/#statuses
     */
    listStatuses(params) {
        return new Paginator(this.http, '/api/v1/trends/statuses', params);
    }
    /**
     * Links that have been shared more than others.
     * @see https://docs.joinmastodon.org/methods/trends/#links
     */
    listLinks(params) {
        return new Paginator(this.http, '/api/v1/trends/links', params);
    }
    /**
     * Tags that are being used more frequently within the past week.
     * @param params Parameters
     * @return Array of Tag with History
     * @see https://docs.joinmastodon.org/methods/trends/#tags
     */
    listTags(params) {
        return new Paginator(this.http, '/api/v1/trends/tags', params);
    }
};
__decorate([
    version({ since: '3.5.0' })
], TrendRepository$1.prototype, "listStatuses", null);
__decorate([
    version({ since: '3.5.0' })
], TrendRepository$1.prototype, "listLinks", null);
__decorate([
    version({ since: '3.0.0' })
], TrendRepository$1.prototype, "listTags", null);

class EmailRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Resend confirmation email
     * @param params Form data parameters
     * @returns Empty object
     * @see https://docs.joinmastodon.org/methods/emails/#confirmation
     */
    createConfirmation(params) {
        return this.http.post('/api/v1/emails/confirmations', params, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
    }
}

class TagRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Show a hashtag and its associated information
     * @param id The name of the hashtag
     * @return Tag
     */
    fetch(id) {
        return this.http.get(`/api/v1/tags/${id}`);
    }
    /**
     * Follow a hashtag. Posts containing a followed hashtag will be inserted into your home timeline.
     * @param id The name of the hashtag
     * @return Tag
     */
    follow(id) {
        return this.http.post(`/api/v1/tags/${id}/follow`);
    }
    /**
     * Unfollow a hashtag. Posts containing a followed hashtag will no longer be inserted into your home timeline.
     * @param id The name of the hashtag
     * @return Tag
     */
    unfollow(id) {
        return this.http.post(`/api/v1/tags/${id}/unfollow`);
    }
}
__decorate([
    version({ since: '4.0.0' })
], TagRepository.prototype, "fetch", null);
__decorate([
    version({ since: '4.0.0' })
], TagRepository.prototype, "follow", null);
__decorate([
    version({ since: '4.0.0' })
], TagRepository.prototype, "unfollow", null);

class FollowedTagRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    list(params) {
        return new Paginator(this.http, '/api/v1/followed_tags', params);
    }
}
__decorate([
    version({ since: '4.0.0' })
], FollowedTagRepository.prototype, "list", null);

class AccountRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View accounts matching certain criteria for filtering, up to 100 at a time.
     * Pagination may be done with the HTTP Link header in the response.
     * @param params Parameters
     * @return Array of AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/admin/accounts', params);
    }
    /**
     * View admin-level information about the given account.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    fetch(id) {
        return this.http.get(`/api/v1/admin/accounts/${id}`);
    }
    /**
     * Perform an action against an account and log this action in the moderation history.
     * @param id g ID of the account
     * @param params Params
     * @return Account
     * @see https://docs.joinmastodon.org/methods/admin/accounts/#action
     */
    createAction(id, params) {
        return this.http.post(`/api/v1/admin/accounts/${id}/action`, params);
    }
    /**
     * Approve the given local account if it is currently pending approval.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    approve(id) {
        return this.http.post(`/api/v1/admin/accounts/${id}/approve`);
    }
    /**
     * Reject the given local account if it is currently pending approval.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    reject(id) {
        return this.http.post(`/api/v1/admin/accounts/${id}/reject`);
    }
    /**
     * Re-enable a local account whose login is currently disabled.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    enable(id) {
        return this.http.post(`/api/v1/admin/accounts/${id}/enable`);
    }
    /**
     * Unsilence a currently silenced account.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    unsilence(id) {
        return this.http.post(`/api/v1/admin/accounts/${id}/unsilence`);
    }
    /**
     * Unsuspend a currently suspended account.
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    unsuspend(id) {
        return this.http.post(`/api/v1/admin/accounts/${id}/unsuspend`);
    }
    /**
     * Unmark an account as sensitive
     * @param id ID of the account
     * @return AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/accounts/#unsensitive
     */
    unsensitive(id) {
        return this.http.post(`/api/v1/admin/accounts/${id}/unsensitive`);
    }
}
__decorate([
    version({ since: '2.9.1' })
], AccountRepository.prototype, "list", null);
__decorate([
    version({ since: '2.9.1' })
], AccountRepository.prototype, "fetch", null);
__decorate([
    version({ since: '2.9.1' })
], AccountRepository.prototype, "createAction", null);
__decorate([
    version({ since: '2.9.1' })
], AccountRepository.prototype, "approve", null);
__decorate([
    version({ since: '2.9.1' })
], AccountRepository.prototype, "reject", null);
__decorate([
    version({ since: '2.9.1' })
], AccountRepository.prototype, "enable", null);
__decorate([
    version({ since: '2.9.1' })
], AccountRepository.prototype, "unsilence", null);
__decorate([
    version({ since: '2.9.1' })
], AccountRepository.prototype, "unsuspend", null);
__decorate([
    version({ since: '2.9.1' })
], AccountRepository.prototype, "unsensitive", null);

class CanonicalEmailBlockRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * List all canonical email blocks.
     * @param params Parameters
     * @return Array of CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks/
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/admin/canonical_email_blocks', params);
    }
    /**
     * Show a single canonical email block
     * @param id id of the canonical email
     * @return CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks
     */
    fetch(id) {
        return this.http.get(`/api/v1/admin/canonical_email_blocks/${id}`);
    }
    /**
     * Canonicalize and hash an email address.
     * @param params Parameters
     * @return Array of CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks/#test
     */
    test(params) {
        return this.http.post('/api/v1/admin/canonical_email_blocks/test', params, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
    }
    /**
     * Block a canonical email.
     * @param params Parameters
     * @return CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks
     */
    create(params) {
        return this.http.post('/api/v1/admin/canonical_email_blocks', params, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
    }
    /**
     * Lift a block a canonical email.
     * @param id id of canonical email
     * @return null
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks
     */
    remove(id) {
        return this.http.delete(`/api/v1/admin/canonical_email_blocks/${id}`);
    }
}
__decorate([
    version({ since: '4.0.0' })
], CanonicalEmailBlockRepository.prototype, "list", null);
__decorate([
    version({ since: '4.0.0' })
], CanonicalEmailBlockRepository.prototype, "fetch", null);
__decorate([
    version({ since: '4.0.0' })
], CanonicalEmailBlockRepository.prototype, "test", null);
__decorate([
    version({ since: '4.0.0' })
], CanonicalEmailBlockRepository.prototype, "create", null);
__decorate([
    version({ since: '4.0.0' })
], CanonicalEmailBlockRepository.prototype, "remove", null);

class DimensionRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Obtain information about popularity of certain accounts, servers, languages, etc.
     * @see https://docs.joinmastodon.org/methods/admin/dimensions/#get
     */
    fetch(params) {
        return this.http.post('/api/v1/admin/dimensions', params);
    }
}

class DomainAllowRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Show information about all allowed domains
     * @param params Parameters
     * @return Array of DomainAllow
     * @see https://docs.joinmastodon.org/methods/admin/domain_allows/#get
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/admin/domain_allows', params);
    }
    /**
     * Show information about a single allowed domain
     * @param id id of the domain
     * @return DomainAllow
     * @see https://docs.joinmastodon.org/methods/admin/domain_allows/#get-one
     */
    fetch(id) {
        return this.http.get(`/api/v1/admin/domain_allows/${id}`);
    }
    /**
     * Add a domain to the list of domains allowed to federate,
     * to be used when the instance is in allow-list federation mode.
     * @param params parameters
     * @return DomainAllow
     * @see https://docs.joinmastodon.org/methods/admin/domain_allows/#get-one
     */
    create(params) {
        return this.http.post('/api/v1/admin/domain_allows', params);
    }
    /**
     * Delete a domain from the allowed domains list.
     * @param id id of domain
     * @return DomainAllow
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    remove(id) {
        return this.http.delete(`/api/v1/admin/domain_allows/${id}`);
    }
}
__decorate([
    version({ since: '4.0.0' })
], DomainAllowRepository.prototype, "list", null);
__decorate([
    version({ since: '4.0.0' })
], DomainAllowRepository.prototype, "fetch", null);
__decorate([
    version({ since: '4.0.0' })
], DomainAllowRepository.prototype, "create", null);
__decorate([
    version({ since: '4.0.0' })
], DomainAllowRepository.prototype, "remove", null);

class DomainBlockRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     *
     * @param params Parameters
     * @return Array of DomainBlocks
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/admin/domain_blocks', params);
    }
    /**
     * Show information about a single blocked domain.
     * @param id ID of the account
     * @return DomainBlocks
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    fetch(id) {
        return this.http.get(`/api/v1/admin/domain_blocks/${id}`);
    }
    /**
     * Add a domain to the list of domains blocked from federating.
     * @param params Parameters
     * @return DomainBlocks
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    create(params) {
        return this.http.post('/api/v1/admin/domain_blocks', params);
    }
    /**
     * Change parameters for an existing domain block.
     * @param id id of domain
     * @param params Parameters
     * @return DomainBlocks
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    update(id, params) {
        return this.http.put(`/api/v1/admin/domain_blocks/${id}`, params);
    }
    /**
     * Lift a block against a domain.
     * @param id id of domain
     * @return DomainBlocks
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    remove(id) {
        return this.http.delete(`/api/v1/admin/domain_blocks/${id}`);
    }
}
__decorate([
    version({ since: '4.0.0' })
], DomainBlockRepository.prototype, "list", null);
__decorate([
    version({ since: '4.0.0' })
], DomainBlockRepository.prototype, "fetch", null);
__decorate([
    version({ since: '4.0.0' })
], DomainBlockRepository.prototype, "create", null);
__decorate([
    version({ since: '4.0.0' })
], DomainBlockRepository.prototype, "update", null);
__decorate([
    version({ since: '4.0.0' })
], DomainBlockRepository.prototype, "remove", null);

class EmailDomainBlockRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Show information about all email domains blocked from signing up.
     * @param params Parameters
     * @return Array of EmailDomainBlock
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/admin/email_domain_blocks ', params);
    }
    /**
     * Show information about a single email domain that is blocked from sign-ups.
     * @param id id of the DomainBlock
     * @return Array of EmailDomainBlock
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    fetch(id) {
        return this.http.get(`/api/v1/admin/email_domain_blocks/${id}`);
    }
    /**
     * Add a domain to the list of email domains blocked from sign-ups.
     * @param params Parameters
     * @return Array of EmailDomainBlock
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    create(params) {
        return this.http.post('/api/v1/admin/email_domain_blocks ', params);
    }
    /**
     * Lift a block against an email domain.
     * @param id id of domain
     * @return null
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    remove(id) {
        return this.http.delete(`/api/v1/admin/email_domain_blocks/${id}`);
    }
}
__decorate([
    version({ since: '4.0.0' })
], EmailDomainBlockRepository.prototype, "list", null);
__decorate([
    version({ since: '4.0.0' })
], EmailDomainBlockRepository.prototype, "fetch", null);
__decorate([
    version({ since: '4.0.0' })
], EmailDomainBlockRepository.prototype, "create", null);
__decorate([
    version({ since: '4.0.0' })
], EmailDomainBlockRepository.prototype, "remove", null);

class IpBlockRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Show information about all blocked IP ranges.
     * @param params Parameters
     * @return Array of Ip Block
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/admin/ip_blocks', params);
    }
    /**
     * Show information about all blocked IP ranges.
     * @param id id of the Ip blocked
     * @return object of Ip Block
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    fetch(id) {
        return this.http.get(`/api/v1/admin/ip_blocks/${id}`);
    }
    /**
     * Add an IP address range to the list of IP blocks.
     * @param params Parameters
     * @return object of Ip Block
     * @see https://docs.joinmastodon.org/methods/admin/ip_blocks/#create
     */
    create(params) {
        return this.http.post('/api/v1/admin/ip_blocks', params);
    }
    /**
     * Change parameters for an existing IP block.
     * @param params Parameters
     * @return object of Ip Block
     * @see https://docs.joinmastodon.org/methods/admin/ip_blocks/#update
     */
    update(id, params) {
        return this.http.put(`/api/v1/admin/ip_blocks/${id}`, params);
    }
    /**
     * Lift a block against an IP range.
     * @param id id of ip block
     * @return null
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    remove(id) {
        return this.http.delete(`/api/v1/admin/ip_blocks/${id}`);
    }
}
__decorate([
    version({ since: '4.0.0' })
], IpBlockRepository.prototype, "list", null);
__decorate([
    version({ since: '4.0.0' })
], IpBlockRepository.prototype, "fetch", null);
__decorate([
    version({ since: '4.0.0' })
], IpBlockRepository.prototype, "create", null);
__decorate([
    version({ since: '4.0.0' })
], IpBlockRepository.prototype, "update", null);
__decorate([
    version({ since: '4.0.0' })
], IpBlockRepository.prototype, "remove", null);

class MeasureRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Obtain quantitative metrics about the server.
     * @see https://docs.joinmastodon.org/methods/admin/measures/#get
     */
    fetch(params) {
        return this.http.post('/api/v1/admin/measures', params);
    }
}
__decorate([
    version({ since: '3.5.0' })
], MeasureRepository.prototype, "fetch", null);

class ReportRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View all reports. Pagination may be done with HTTP Link header in the response.
     * @param params Parameters
     * @return Array of AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params) {
        return new Paginator(this.http, '/api/v1/admin/reports', params);
    }
    /**
     * View information about the report with the given ID.
     * @param id ID of the report
     * @return AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    fetch(id) {
        return this.http.get(`/api/v1/admin/reports/${id}`);
    }
    /**
     * Claim the handling of this report to yourself.
     * @param id ID of the report
     * @return AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    assignToSelf(id) {
        return this.http.post(`/api/v1/admin/reports/${id}/assign_to_self`);
    }
    /**
     * Unassign a report so that someone else can claim it.
     * @param id ID of the report
     * @return AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    unassign(id) {
        return this.http.post(`/api/v1/admin/reports/${id}/unassign`);
    }
    /**
     * Mark a report as resolved with no further action taken.
     * @param id ID of the report
     * @return AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    resolve(id) {
        return this.http.post(`/api/v1/admin/reports/${id}/resolve`);
    }
    /**
     * Reopen a currently closed report.
     * @param id ID of the report
     * @return AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    reopen(id) {
        return this.http.post(`/api/v1/admin/reports/${id}/reopen`);
    }
}
__decorate([
    version({ since: '2.9.1' })
], ReportRepository.prototype, "list", null);
__decorate([
    version({ since: '2.9.1' })
], ReportRepository.prototype, "fetch", null);
__decorate([
    version({ since: '2.9.1' })
], ReportRepository.prototype, "assignToSelf", null);
__decorate([
    version({ since: '2.9.1' })
], ReportRepository.prototype, "unassign", null);
__decorate([
    version({ since: '2.9.1' })
], ReportRepository.prototype, "resolve", null);
__decorate([
    version({ since: '2.9.1' })
], ReportRepository.prototype, "reopen", null);

class RetentionRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Generate a retention data report for a given time period and bucket.
     * @see https://docs.joinmastodon.org/methods/admin/retention/#create
     */
    create(params) {
        return this.http.post('/api/v1/admin/retention', params);
    }
}

class TrendRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Links that have been shared more than others, including unapproved and unreviewed links.
     * @see https://docs.joinmastodon.org/methods/admin/trends/#links
     */
    listLinks() {
        return new Paginator(this.http, '/api/v1/admin/trends/links');
    }
    /**
     * Statuses that have been interacted with more than others, including unapproved and unreviewed statuses.
     * @see https://docs.joinmastodon.org/methods/admin/trends/#statuses
     */
    listStatuses() {
        return new Paginator(this.http, '/api/v1/admin/trends/statuses');
    }
    /**
     * Tags that are being used more frequently within the past week, including unapproved and unreviewed tags.
     * @see https://docs.joinmastodon.org/methods/admin/trends/#tags
     */
    listTags() {
        return new Paginator(this.http, '/api/v1/admin/trends/statuses');
    }
}
__decorate([
    version({ since: '3.5.0' })
], TrendRepository.prototype, "listLinks", null);
__decorate([
    version({ since: '3.5.0' })
], TrendRepository.prototype, "listStatuses", null);
__decorate([
    version({ since: '3.5.0' })
], TrendRepository.prototype, "listTags", null);

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AccountRepository: AccountRepository,
  CanonicalEmailBlockRepository: CanonicalEmailBlockRepository,
  DimensionRepository: DimensionRepository,
  DomainAllowRepository: DomainAllowRepository,
  DomainBlockRepository: DomainBlockRepository,
  EmailDomainBlockRepository: EmailDomainBlockRepository,
  IpBlockRepository: IpBlockRepository,
  MeasureRepository: MeasureRepository,
  ReportRepository: ReportRepository,
  RetentionRepository: RetentionRepository,
  TrendRepository: TrendRepository
});

class AggregateRepositoryAdmin {
    /** @deprecated Use `accounts` instead */
    /* istanbul ignore next */
    get account() {
        return this.accounts;
    }
    /** @deprecated Use `reports` instead */
    /* istanbul ignore next */
    get report() {
        return this.reports;
    }
    /** @deprecated Use `emailDomainBlocks` instead */
    /* istanbul ignore next */
    get domainEmailBlocks() {
        return this.emailDomainBlocks;
    }
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
        this.accounts = new AccountRepository(this.http, this.config, this.logger);
        this.canonicalEmailBlocks =
            new CanonicalEmailBlockRepository(this.http, this.config, this.logger);
        this.dimensions = new DimensionRepository(this.http, this.config, this.logger);
        this.domainBlocks = new DomainBlockRepository(this.http, this.config, this.logger);
        this.domainAllows = new DomainAllowRepository(this.http, this.config, this.logger);
        this.emailDomainBlocks = new EmailDomainBlockRepository(this.http, this.config, this.logger);
        this.ipBlocks = new IpBlockRepository(this.http, this.config, this.logger);
        this.measures = new MeasureRepository(this.http, this.config, this.logger);
        this.reports = new ReportRepository(this.http, this.config, this.logger);
        this.retention = new RetentionRepository(this.http, this.config, this.logger);
        this.trends = new TrendRepository(this.http, this.config, this.logger);
    }
}

let AggregateRepository$1 = class AggregateRepository {
    constructor(http, ws, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
        this.admin = new AggregateRepositoryAdmin(http, config, logger);
        this.stream = new StreamRepository(ws, config, logger);
        this.accounts = new AccountRepository$1(http, config, logger);
        this.announcements = new AnnouncementRepository(http, config, logger);
        this.apps = new AppRepository(http, config, logger);
        this.blocks = new BlockRepository(http, config, logger);
        this.bookmarks = new BookmarkRepository(http, config, logger);
        this.conversations = new ConversationRepository(http, config, logger);
        this.customEmojis = new CustomEmojiRepository(http, config, logger);
        this.directory = new DirectoryRepository(http, config, logger);
        this.domainBlocks = new DomainBlockRepository$1(http, config, logger);
        this.endorsements = new EndorsementRepository(http, config, logger);
        this.favourites = new FavouriteRepository(http, config, logger);
        this.featuredTags = new FeaturedTagRepository(http, config, logger);
        this.filters = new FilterRepository$1(http, config, logger);
        this.followRequests = new FollowRequestRepository(http, config, logger);
        this.instances = new InstanceRepository$1(http, config, logger);
        this.lists = new ListRepository(http, config, logger);
        this.markers = new MarkerRepository(http, config, logger);
        this.mediaAttachments = new MediaAttachmentRepository$1(http, config, logger);
        this.mutes = new MuteRepository(http, config, logger);
        this.notifications = new NotificationRepository(http, config, logger);
        this.polls = new PollRepository(http, config, logger);
        this.preferences = new PreferenceRepository(http, config, logger);
        this.webPushSubscriptions = new WebPushSubscriptionRepository(http, config, logger);
        this.reports = new ReportRepository$1(http, config, logger);
        this.scheduledStatuses = new ScheduledStatusRepository(http, config, logger);
        this.statuses = new StatusRepository(http, config, logger);
        this.suggestions = new SuggestionRepository$1(http, config, logger);
        this.timelines = new TimelineRepository(http, config, logger);
        this.trends = new TrendRepository$1(http, config, logger);
        this.emails = new EmailRepository(http, config, logger);
        this.tags = new TagRepository(http, config, logger);
        this.followedTags = new FollowedTagRepository(http, config, logger);
    }
    /**
     * Search, but hashtags is an array of strings instead of an array of Tag.
     * @param params Parameters
     * @return Results
     * @see https://docs.joinmastodon.org/methods/search/
     */
    /* istanbul ignore next */
    search(params) {
        return new Paginator(this.http, `/api/v1/search`, params);
    }
};
__decorate([
    version({ since: '1.1.0', until: '3.0.0' })
], AggregateRepository$1.prototype, "search", null);

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AccountRepository: AccountRepository$1,
  Admin: index$4,
  AdminRepositories: index$3,
  AggregateRepository: AggregateRepository$1,
  AggregateRepositoryAdmin: AggregateRepositoryAdmin,
  AnnouncementRepository: AnnouncementRepository,
  AppRepository: AppRepository,
  BlockRepository: BlockRepository,
  BookmarkRepository: BookmarkRepository,
  ConversationRepository: ConversationRepository,
  CustomEmojiRepository: CustomEmojiRepository,
  DirectoryRepository: DirectoryRepository,
  DomainBlockRepository: DomainBlockRepository$1,
  EmailRepository: EmailRepository,
  EndorsementRepository: EndorsementRepository,
  FavouriteRepository: FavouriteRepository,
  FeaturedTagRepository: FeaturedTagRepository,
  FilterRepository: FilterRepository$1,
  FollowRequestRepository: FollowRequestRepository,
  FollowedTagRepository: FollowedTagRepository,
  InstanceRepository: InstanceRepository$1,
  ListRepository: ListRepository,
  MarkerRepository: MarkerRepository,
  MediaAttachmentRepository: MediaAttachmentRepository$1,
  MuteRepository: MuteRepository,
  NotificationRepository: NotificationRepository,
  PollRepository: PollRepository,
  PreferenceRepository: PreferenceRepository,
  ReportRepository: ReportRepository$1,
  ScheduledStatusRepository: ScheduledStatusRepository,
  StatusRepository: StatusRepository,
  StreamRepository: StreamRepository,
  SuggestionRepository: SuggestionRepository$1,
  TagRepository: TagRepository,
  TimelineRepository: TimelineRepository,
  TrendRepository: TrendRepository$1,
  WebPushSubscriptionRepository: WebPushSubscriptionRepository
});

class FilterRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View all filters
     * @return Array of Filter
     * @see https://docs.joinmastodon.org/methods/filters/#get
     */
    list() {
        return new Paginator(this.http, `/api/v2/filters`);
    }
    /**
     * Obtain a single filter group owned by the current user.
     * @param id ID of the filter
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/filters/#get-one
     */
    fetch(id) {
        return this.http.get(`/api/v2/filters/${id}`);
    }
    /**
     * Create a filter group with the given parameters.
     * @param params Parameters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/filters/#create
     */
    create(params) {
        return this.http.post(`/api/v2/filters`, params, {
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        });
    }
    /**
     * Update a filter group with the given parameters.
     * @param id ID of the filter in the database
     * @param params Parameters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/filters/#update
     */
    update(id, params) {
        return this.http.put(`/api/v2/filters/${id}`, params);
    }
    /**
     * Delete a filter group with the given id.
     * @param id ID of the filter in the database
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/filters/#delete
     */
    remove(id) {
        return this.http.delete(`/api/v2/filters/${id}`);
    }
    /**
     * List all keywords attached to the current filter group.
     * @param id String. The ID of the Filter in the database.
     * @returns Array of FilterKeyword
     * @see https://docs.joinmastodon.org/methods/filters/#keywords-get
     */
    listKeywords(id) {
        return new Paginator(this.http, `/api/v2/filters/${id}/keywords`);
    }
    /**
     * Add the given keyword to the specified filter group
     * @param id String. The ID of the Filter in the database.
     * @param params Parameters
     * @return FilterKeywords
     * @see https://docs.joinmastodon.org/methods/filters/#keywords-create
     */
    createKeyword(id, params) {
        return this.http.post(`/api/v2/filters/${id}/keywords`, params, {
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        });
    }
    /**
     * Get one filter keyword by the given id.
     * @param id String. The ID of the FilterKeyword in the database.
     * @returns FilterKeyword
     * @see https://docs.joinmastodon.org/methods/filters/#keywords-get-one
     */
    fetchKeyword(id) {
        return new Paginator(this.http, `/api/v2/filters/keywords/${id}`);
    }
    /**
     * Update the given filter keyword.
     * @param id String. The ID of the FilterKeyword in the database.
     * @param params Parameters
     * @return FilterKeywords
     * @see https://docs.joinmastodon.org/methods/filters/#keywords-update
     */
    updateKeyword(id, params) {
        return this.http.put(`/api/v2/filters/keywords/${id}`, params, {
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        });
    }
    /**
     * Deletes the given filter keyword.
     * @param id String. The ID of the FilterKeyword in the database.
     * @returns empty object
     * @see https://docs.joinmastodon.org/methods/filters/#keywords-delete
     */
    removeKeyword(id) {
        return this.http.delete(`/api/v2/filters/keywords/${id}`);
    }
    /**
     * Obtain a list of all status filters within this filter group.
     * @param id String. The ID of the Filter in the database.
     * @returns Array of FilterStatus
     * @see https://docs.joinmastodon.org/methods/filters/#statuses-get
     */
    listStatuses(id) {
        return new Paginator(this.http, `/api/v2/filters/${id}/statuses`);
    }
    /**
     * Add a status filter to the current filter group.
     * @param id String. The ID of the Filter in the database.
     * @param params
     * @returns FilterStatus
     * @see https://docs.joinmastodon.org/methods/filters/#statuses-add
     */
    createStatus(id, params) {
        return this.http.post(`/api/v2/filters/${id}/statuses`, params);
    }
    /**
     * Obtain a single status filter.
     * @param id String. The ID of the FilterStatus in the database.
     * @returns FilterStatus
     * @see https://docs.joinmastodon.org/methods/filters/#statuses-get-one
     */
    fetchStatus(id) {
        return this.http.get(`/api/v2/filters/statuses/${id}`);
    }
    /**
     * @param id String. The ID of the FilterStatus in the database.
     * @returns FilterStatus
     * @see https://docs.joinmastodon.org/methods/filters/#statuses-get-one
     */
    removeStatus(id) {
        return this.http.get(`/api/v2/filters/statuses/${id}`);
    }
}
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "list", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "fetch", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "create", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "update", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "remove", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "listKeywords", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "createKeyword", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "fetchKeyword", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "updateKeyword", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "removeKeyword", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "listStatuses", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "fetchStatus", null);
__decorate([
    version({ since: '4.0.0' })
], FilterRepository.prototype, "removeStatus", null);

class InstanceRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Information about the server.
     * @return Instance
     * @see https://docs.joinmastodon.org/methods/instance/
     */
    fetch() {
        return this.http.get('/api/v2/instance');
    }
}
__decorate([
    version({ since: '4.0.0' })
], InstanceRepository.prototype, "fetch", null);

// Repository<V1.MediaAttachment, CreateMediaAttachmentParams>;
class MediaAttachmentRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
        this.v1 = new MediaAttachmentRepository$1(http, config);
    }
    /**
     * @experimental
     * @param id ID of the media
     * @param interval interval of polling
     * @returns Media attachment that has done processing
     */
    waitFor(id, interval = 1000) {
        return __awaiter(this, void 0, void 0, function* () {
            const timeout = this.config.createTimeout();
            let media;
            while (media == undefined) {
                if (timeout.signal.aborted) {
                    throw new MastoTimeoutError('The media encoding has been timed out in your instance.');
                }
                yield delay(interval);
                try {
                    const processing = yield this.v1.fetch(id);
                    if (processing.url != undefined) {
                        media = processing;
                        timeout.clear();
                    }
                }
                catch (error) {
                    // Some instance caches API response
                    if (error instanceof MastoHttpNotFoundError) {
                        continue;
                    }
                    throw error;
                }
            }
            return media;
        });
    }
    /**
     * Creates an attachment to be used with a new status.
     * @param params Parameters
     * @return Attachment
     * @see https://docs.joinmastodon.org/methods/statuses/media/
     */
    create(params, extra = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const media = yield this.http.post(`/api/v2/media`, params, { headers: { 'Content-Type': 'multipart/form-data' } });
            if (extra.skipPolling) {
                return media;
            }
            return this.waitFor(media.id);
        });
    }
}
__decorate([
    version({ since: '3.1.3' })
], MediaAttachmentRepository.prototype, "create", null);

class SuggestionRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
    }
    /**
     * View follow suggestions.
     * Accounts that are promoted by staff, or that the user has had past positive interactions with, but is not yet following.
     * @param params
     * @returns
     */
    list(params) {
        return new Paginator(this.http, '/api/v2/suggestions', params);
    }
}
__decorate([
    version({ since: '3.4.0' })
], SuggestionRepository.prototype, "list", null);

class AggregateRepository {
    constructor(http, config, logger) {
        this.http = http;
        this.config = config;
        this.logger = logger;
        this.filters = new FilterRepository(http, config, logger);
        this.instance = new InstanceRepository(http, config, logger);
        this.mediaAttachments = new MediaAttachmentRepository(http, config, logger);
        this.suggestions = new SuggestionRepository(http, config, logger);
    }
    /**
     * Perform a search
     * @param params Parameters
     * @return Results
     * @see https://docs.joinmastodon.org/methods/search/
     */
    search(params) {
        return new Paginator(this.http, `/api/v2/search`, params);
    }
}
__decorate([
    version({ since: '2.4.1' })
], AggregateRepository.prototype, "search", null);

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AggregateRepository: AggregateRepository,
  FilterRepository: FilterRepository,
  InstanceRepository: InstanceRepository,
  MediaAttachmentRepository: MediaAttachmentRepository,
  SuggestionRepository: SuggestionRepository
});

/**
 * @experimental
 */
class OAuthRepository {
    constructor(http) {
        this.http = http;
    }
    createToken(params) {
        return this.http.post('/oauth/token', params, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
    }
}

class Client {
    constructor(http, ws, config, logger) {
        this.http = http;
        this.ws = ws;
        this.config = config;
        this.logger = logger;
        this.v1 = new AggregateRepository$1(http, ws, config, logger);
        this.v2 = new AggregateRepository(http, config, logger);
        this.oauth = new OAuthRepository(http);
    }
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Client: Client,
  v1: index$2,
  v2: index$1
});

const isObject = (x) => typeof x === 'object' && x !== null && x.constructor.name === 'Object';

const flattenObject = (object, parent = '') => {
    if (Array.isArray(object)) {
        return object
            .map((value, i) => flattenObject(value, parent == '' ? i.toString() : `${parent}[${i}]`))
            .reduce((prev, curr) => Object.assign(prev, curr), {});
    }
    if (isObject(object)) {
        return Object.entries(object)
            .map(([key, value]) => flattenObject(value, parent === '' ? key : `${parent}[${key}]`))
            .reduce((prev, curr) => Object.assign(prev, curr), {});
    }
    // Unit of the monoid is always an object
    return parent === ''
        ? object
        : { [parent]: object };
};

const _transformKeys = (data, transform) => {
    if (Array.isArray(data)) {
        return data.map((value) => transformKeys(value, transform));
    }
    if (isObject(data)) {
        return Object.fromEntries(Object.entries(data).map(([key, value]) => [
            transform(key),
            transformKeys(value, transform),
        ]));
    }
    return data;
};
const transformKeys = (data, transform) => {
    const f = (key) => {
        // `PATCH /v1/preferences` uses `:` as a delimiter
        if (key.includes(':'))
            return key;
        // `PATCH /v2/filters` uses _destroy as a special key
        if (key.startsWith('_'))
            return key;
        return transform(key);
    };
    return _transformKeys(data, f);
};

class SerializerNativeImpl {
    serialize(type, rawData) {
        if (rawData == undefined) {
            return;
        }
        const data = transformKeys(rawData, changeCase.snakeCase);
        switch (type) {
            case 'application/json': {
                return JSON.stringify(data);
            }
            case 'multipart/form-data': {
                const formData = new ponyfills.FormData();
                for (const [key, value] of Object.entries(flattenObject(data))) {
                    // `form-data` module has an issue that they doesn't set filename
                    // https://github.com/neet/masto.js/issues/481
                    // https://github.com/mastodon/mastodon/issues/17622
                    if (globalThis.Buffer != undefined &&
                        value instanceof globalThis.Buffer) {
                        // We set `blob` as filename, which is the default for Blob defined by the spec
                        // https://developer.mozilla.org/en-US/docs/Web/API/FormData/append
                        formData.append(key, value, 'blob');
                        continue;
                    }
                    formData.append(key, value);
                }
                return formData;
            }
            case 'application/x-www-form-urlencoded': {
                return qs.stringify(data, {
                    encode: false,
                    arrayFormat: 'brackets',
                });
            }
            default: {
                return;
            }
        }
    }
    serializeQueryString(rawData) {
        const data = transformKeys(rawData, changeCase.snakeCase);
        return qs.stringify(data, {
            encode: false,
            arrayFormat: 'brackets',
        });
    }
    deserialize(type, data) {
        switch (type) {
            case 'application/json': {
                try {
                    return transformKeys(JSON.parse(data), changeCase.camelCase);
                }
                catch (_a) {
                    return undefined;
                }
            }
            default: {
                throw new MastoDeserializeError(`Unknown content type ${type} returned from the server.`, type, data);
            }
        }
    }
}

/**
 * Mastodon streaming api wrapper
 */
class WsEventsNativeImpl extends EventEmitter {
    constructor(ws, serializer, logger) {
        super();
        this.ws = ws;
        this.serializer = serializer;
        this.logger = logger;
        /**
         * Parse JSON data and emit it as an event
         * @param message Websocket message
         */
        this.handleMessage = ({ data }) => {
            const { event, payload } = this.serializer.deserialize('application/json', data);
            this.logger.info(`↓ WEBSOCKET ${event}`);
            this.logger.debug('\tbody', payload);
            // https://github.com/neet/masto.js/issues/750
            if (event === 'delete') {
                return void this.emit(event, payload);
            }
            let args = [];
            try {
                args.push(this.serializer.deserialize('application/json', payload));
            }
            catch (_a) {
                args = [];
            }
            this.emit(event, ...args);
        };
    }
    /**
     * Connect to the websocket endpoint
     * @param url URL of the websocket endpoint
     * @param protocols Subprotocol(s) for `Sec-Websocket-Protocol`
     * @param params URL parameters
     */
    static connect(url, serializer, logger, protocols) {
        return new Promise((resolve, reject) => {
            const ws = new WebSocket(url, protocols);
            const instance = new WsEventsNativeImpl(ws, serializer, logger);
            ws.addEventListener('message', instance.handleMessage);
            ws.addEventListener('error', reject);
            ws.addEventListener('open', () => resolve(instance));
        });
    }
    /**
     * Disconnect from the websocket endpoint
     */
    disconnect() {
        if (!this.ws)
            return;
        this.ws.close();
    }
}
class WsNativeImpl {
    constructor(config, serializer, logger) {
        this.config = config;
        this.serializer = serializer;
        this.logger = logger;
    }
    stream(path, params = {}) {
        return WsEventsNativeImpl.connect(this.config.resolveWebsocketPath(path, params), this.serializer, this.logger, this.config.createWebsocketProtocols());
    }
}

const buildHttpContext = (params) => {
    const version = params.version && !params.disableVersionCheck
        ? new semver.SemVer(params.version, true)
        : undefined;
    const props = Object.assign(Object.assign({}, params), { version });
    const serializer = new SerializerNativeImpl();
    const config = new MastoConfig(props, serializer);
    const logger = new LoggerConsoleImpl(config.getLogLevel());
    const http = new HttpNativeImpl(serializer, config, logger);
    return { serializer, config, logger, http };
};
const fetchV1Instance = (params) => {
    const { http, config } = buildHttpContext(params);
    return new InstanceRepository$1(http, config).fetch();
};
const fetchV2Instance = (params) => {
    const { http, config } = buildHttpContext(params);
    return new InstanceRepository(http, config).fetch();
};
const createClient = (params) => {
    const { serializer, config, logger, http } = buildHttpContext(params);
    const ws = new WsNativeImpl(config, serializer, logger);
    logger.debug('Masto.js initialised', config);
    return new Client(http, ws, config, logger);
};
/**
 * Fetching instance information and create a client
 *
 * Shortcut of `fetchV1Instance` and `createClient`
 */
const login = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const instance = yield fetchV1Instance(params);
    return createClient(Object.assign(Object.assign({}, params), { version: instance.version, streamingApiUrl: instance.urls.streamingApi }));
});

exports.BaseHttp = BaseHttp;
exports.BaseLogger = BaseLogger;
exports.HttpNativeImpl = HttpNativeImpl;
exports.LogLevel = LogLevel;
exports.LoggerConsoleImpl = LoggerConsoleImpl;
exports.MastoConfig = MastoConfig;
exports.Paginator = Paginator;
exports.SerializerNativeImpl = SerializerNativeImpl;
exports.WsEventsNativeImpl = WsEventsNativeImpl;
exports.WsNativeImpl = WsNativeImpl;
exports.createClient = createClient;
exports.fetchV1Instance = fetchV1Instance;
exports.fetchV2Instance = fetchV2Instance;
exports.login = login;
exports.mastodon = index;
